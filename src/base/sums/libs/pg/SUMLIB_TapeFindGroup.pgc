/* SUMLIB_TapeFindGroup.pgc
 */
#include <SUM.h>
#include <tape.h>
#include <sum_rpc.h>
#include <printk.h>

int SUMLIB_TapeFindGroup(int group, double bytes, TAPE *tape);

/* Called by writedo_1() in tape_svc to determine a tape with enough storage
 * to write the given group on.  If none found, will assign a new tape to
 * this group. Returns 1 if no tape can be found.
*/

int SUMLIB_TapeFindGroup(int group, double bytes, TAPE *tape)
{
  EXEC SQL TYPE uint64_t IS unsigned long long;

EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR l_tapeid[20];
  int  l_nxtwrtfn;
  int  l_spare;
  int  l_group_id;
  int  l_closed;
  uint64_t  l_availblocks;
EXEC SQL END DECLARE SECTION;
  int found = 0;
  double size;

    EXEC SQL WHENEVER SQLERROR GOTO sqlerror;
    l_group_id = group;

        EXEC SQL DECLARE pfind CURSOR FOR
	SELECT tapeid, nxtwrtfn, spare, avail_blocks, closed
        FROM SUM_TAPE
        WHERE GROUP_ID = :l_group_id AND CLOSED != 2
	ORDER BY tapeid;

        EXEC SQL OPEN pfind;
    EXEC SQL WHENEVER NOT FOUND GOTO end_fetch;

    for( ; ; ){
      EXEC SQL FETCH pfind INTO :l_tapeid, :l_nxtwrtfn, :l_spare, :l_availblocks, :l_closed;
      size = (double)l_availblocks;
      size = size * 512.0;
      /*if(size >= (bytes + 10000000.0)) {   give 10MB leeway */
      if(size >= bytes) {
        found = 1;
        /* fill in the tape structure */
        tape->nxtwrtfn = l_nxtwrtfn;
        tape->spare = l_spare;
        tape->group_id = l_group_id;
        tape->availblocks = l_availblocks;
        tape->closed = l_closed;
        tape->tapeid = strdup(l_tapeid.arr);
        EXEC SQL CLOSE pfind;
        EXEC SQL COMMIT;
	printk("SUMLIB_TapeFindGroup found tape %s for group %d\n", 
			l_tapeid.arr, group); 
        return(0);
      }
    }

end_fetch:
    EXEC SQL CLOSE pfind;
    EXEC SQL COMMIT;
    /* now get an unused tape and assign it this group id */
        EXEC SQL DECLARE tfind CURSOR FOR
	SELECT tapeid, nxtwrtfn, spare, avail_blocks, closed
        FROM SUM_TAPE
        WHERE GROUP_ID = -1 AND CLOSED != 2
	ORDER BY tapeid;

        EXEC SQL OPEN tfind;
    EXEC SQL WHENEVER NOT FOUND GOTO end_tfetch;

    found = 0;
    for( ; ; ){
      EXEC SQL FETCH tfind INTO :l_tapeid, :l_nxtwrtfn, :l_spare, :l_availblocks, :l_closed;
      found = 1;
      /* fill in the tape structure */
      tape->nxtwrtfn = l_nxtwrtfn;
      tape->spare = l_spare;
      tape->group_id = l_group_id;
      tape->availblocks = l_availblocks;
      tape->closed = l_closed;
      tape->tapeid = strdup(l_tapeid.arr);
      EXEC SQL CLOSE tfind;
      /* now assign the group to this tapeid */
      EXEC SQL UPDATE SUM_TAPE
		SET GROUP_ID = :l_group_id 
		WHERE TAPEID = :l_tapeid;
      EXEC SQL COMMIT WORK;
      printk("SUMLIB_TapeFindGroup found tape %s for group %d\n", 
			l_tapeid.arr, group); 
      return(0);	/* just need 1st entry */
    }

end_tfetch:
    EXEC SQL CLOSE tfind;
    EXEC SQL COMMIT;
    if(!found) {
      printk("Error in SUMLIB_TapeFindGroup.  Can't find tape for group %d\n", group); 
      return(1);
    }

sqlerror:
    EXEC SQL ROLLBACK WORK;
    printk("Error in SUMLIB_TapeFindGroup.  Can't get tape for group %d\n", group); 
    printk("% .70s \n", sqlca.sqlerrm.sqlerrmc); 
    return(1);
}
