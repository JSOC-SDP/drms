eval 'exec /home/jsoc/bin/$JSOC_MACHINE/perl -S $0 "$@"'
    if 0;
#
#/home/jim/cvs/PROTO/script/SUM/t120view
#Perl/Tk gui for use with tape_svc for Spectra-Logic T120.
#
#Usage: t120view [-h] [-p] [-i] [-llog_file] [-Hdbhost] [DB]
# -h = help. Show this usage message.
# -p = playback mode (vs. real-time mode)
# -i = interactive mode. you can do imp/exp of tapes. mutually exclusive
#      with -p mdoe. The interactive mode requires a password.
# -lfile = the name of the tape_svc log file. The default log_file is the 
#          latest copy of  /usr/local/logs/SUM/tape_svc_(pid).log
# -Hdbhost = host name where the db is running. default is hmidb
#  DB = database name to connect to. Default is hmidbX.
#
#Reads the log file and updates the display from the directive lines that
#are in the log file. The log file is written by tape_svc, drive[n]_svc,
#and robot[n]_svc. These programs and this gui are therefore strongly
#coupled!
#
use Tk;
use Tie::IxHash;
use DBI;
use Term::ReadKey;

sub usage {
  print "Usage: t120view [-h] [-p] [-i] [-llog_file] [-Hdbhost] [DB]\n";
  print "  -h = help. Show this usage message.\n";
  print "  -p = playback mode (vs. real-time mode)\n";
  print "  -i = interactive mode. you can do imp/exp of tapes. mutually exclusive\n";
  print "       with -p mdoe. The interactive mode requires a password.\n";
  print "  -lfile = the name of the tape_svc log file. The default log_file is the\n";
  print "           latest copy of  /usr/local/logs/SUM/tape_svc_(pid).log\n";
  print "  -Hdbhost = host name where the db is running. default is hmidb\n";
  print "   DB = database name to connect to. Default is $DEFAULTDB.\n";
  exit;
}


%Hofrdq = ();		#hash key is ds_index
%Hofwtq = ();		#hash key is ds_index
%Hofreplace = ();	#key is tapeid. tape replaced in input order
%Hofneed = ();		#key is tapeid. tape imported in input order
tie %Hofrdq, "Tie::IxHash"; #lets you take out keys in input order
tie %Hofwtq, "Tie::IxHash"; #lets you take out keys in input order
tie %Hofreplace, "Tie::IxHash"; #lets you take out keys in input order
tie %Hofneed, "Tie::IxHash"; #lets you take out keys in input order

#NOTE: must have our full path name here for any restart signaled by sum_svc
$OURPATH = "/home/production/cvs/jsoc/scripts/sum/t120view"; #!!this program

$DEFAULTDB = "hmidbX";		#default DB
$HOSTDB = "hmidb";		#host where DB runs
$INLOG = 0;			#use default tape_svc log
#$login = "dsowner";
#$passw = "hmi4sdo";
$pid0 = 0;

$MAX_SLOTS = 120;
$NUM_IMP_EXP_SLOTS = 8;
$MAX_Q_ENTIRES = 5;
$EEcnt = 0;
$ldate = &labeldate();
$user = $ENV{'USER'};

while ($ARGV[0] =~ /^-/) {
  $_ = shift;
  if (/^-l(.*)/) {
    $INLOG = $1;
  }
  elsif (/^-p(.*)/) {
    $playback = 1;
  }
  elsif (/^-H(.*)/) {
    $HOSTDB = $1;
  }
  elsif (/^-h(.*)/) {
    $helpflg = 1;
  }
  elsif (/^-i(.*)/) {
    $interactive = 1;
  }
  elsif (/^-r(.*)/) {
    $restartmode = 1;
  }
  else {
    &usage;
  }
}
if($#ARGV == 0) {
  $DB = $ARGV[0];
}
else {
  $DB = $DEFAULTDB; 
}
if($helpflg) { &usage; }
if($playback && $interactive) {
  print "Playback and interactive are mutually exclusive.\n";
  &usage;
}
#$ENV{'TNS_ADMIN'} = "/home/soi/CM/src/oracle/setup"; #!!TBD fix
#$ENV{'ORACLE_SID'} = $DB;
#$ENV{'TWO_TASK'} = $DB;
#$user = "jim";
$hostdb = $HOSTDB;      #host where Postgres runs
$UID = $<;              #get real user id
#$HOME = $ENV{'HOME'};

$runtag = "/tmp/t120view_$UID.tag";
if(-e $runtag) {        #this user already running
  print "Already found a $runtag\n";
  print "Only one instance of t120view allowed for a user\n";
  print "If not so do: /bin/rm $runtag\n";
  exit(1);
}

@pst120 = `ps -ef | grep sum_svc`;
#@sumsvc = grep(/hmidb/, @pst120);
#if($line = shift(@sumsvc)) {
while($line = shift(@pst120)) {
  ($x, $sumdb) = split(/sum_svc /, $line); 
  if($sumdb) {
    chomp($sumdb);
    if($sumdb =~ /-s/) {
      ($x, $sumdb) = split(/ /, $sumdb); #ignore any sim -s flag
    }
    if($sumdb ne $DB) {
      print "t120view db=$DB does not match running sum_svc=$sumdb\n";
      exit;
    }
    last;
  }    
}
#if($sumdb ne $DB) {
#  print "t120view db=$DB does not match that of the running sum_svc=$sumdb\n";
#  exit;
#}

if($interactive && !$restartmode) {
  if($user ne "production") {
    print "You must be user production to run t120view in interactive mode\n";
    exit;
  }
  print "Need password to run interactive mode: passwd =";
  ReadMode('noecho');
  $passwd = ReadLine(0);
  chomp($passwd);
  ReadMode('normal');
  print "\n";
  if($passwd ne "hmi4sdo") {
    print "Invalid passwd\n";
    exit(1);
  }
}
$ext = "$user"."_$ldate";
$log = "/usr/local/logs/SUM/t120view_$ext.log";
open(LOG, ">$log") || die "Can't open $log: $!\n";
select(LOG); $| = 1; select(STDOUT);	#make unbuffered
print LOG "$ldate $log\n\n";
my(@pl) = qw/-side top -anchor nw/;
my(@pl1) = qw/-side top/;
my(@pl2) = qw/-side top -pady 1.0m/;
my(@pl3) = qw/-side left/;

#First connect to database
  #$dbh = DBI->connect( '', "$login", "$passw", 'Oracle' );
  $dbh = DBI->connect("dbi:Pg:dbname=$DB;host=$hostdb", "$user", "$password");
  if ( !defined $dbh ) {
    die "Cannot do \$dbh->connect: $DBI::errstr\n";
  }

system "touch $runtag";		#offically started running now

####!!!TEMP for testing
&get_exp_tapes; #!!!TEMP
print "exptapes = @exptape\n";
$expnum = $#exptape+1;
print "num of exptape = $expnum\n";
$date = &get_effdate;
print "effdate = $date\n";

  $mw = MainWindow->new;
  #$mw->Photo('image1', -file => 'SDO_Badge.gif');
  #$mw->Label(-image => 'image1')->pack(@pl);
  $tframe = $mw->Frame(-borderwidth => 1)->pack(-side => 'top');
  $tframe->Label(-text => "T120 User Interface (tui) for db=$DB on $HOSTDB",
	-font => 'arial 18 bold', -padx => 150)->pack(-side => 'left');
  $b0text = "Imp/Exp\n$EEcnt";
  $b0 = $tframe->Button(
        -text => $b0text,
        -background => 'grey',
        -command =>  \&ImpExp_sub, 
        );
  $b0->pack(-side=> 'left', -pady => 0, -padx => 40);
  $b = $tframe->Button(
        -text => 'Exit',
        -background => 'red',
        -command => \&Exit_sub,
        );
  $b->pack(-side=> 'left', -pady => 0);

  #$mw->Photo('image2', -file => 'GRAD_BLUE_LINE.gif');
  #$mw->Label(-image => 'image2')->pack(@pl2);
  $mw->Label(-text => 'Slot#    Tape_id', -font => 'arial 12 bold')->pack(@pl);
  $f0 = $mw->Frame(-borderwidth => 3, -relief=>'groove')
		->pack(-side => 'left');
  if($INLOG) {
    $tapelog = $INLOG;
  }
  else {
    $tapelog = `ls -t /usr/local/logs/SUM/tape_svc*.log | sed -n 1p`;
    chomp $tapelog;
  }
  if(!-e $tapelog) {
    print "ERROR: No such log file $tapelog\n";
    system "/bin/rm $runtag";
    exit;
  }
  &show_notape_in_slots;	#show blank tape slots

  $d0tape = "-------------";
  $d1tape = "-------------";
  $d2tape = "-------------";
  $d3tape = "-------------";

  my $fop = $mw->Frame(-borderwidth => 0, -relief=>'flat')
                ->pack(-side => 'top', -pady=>5);
  my $lopa = $fop->Label(-text => 'Operation colors: ', -anchor => 'w',
		-background=>'grey')->pack(-side=> 'left');
  my $lopb = $fop->Label(-text => ' robot ', -anchor => 'w',
		-background=>'yellow')->pack(-side=> 'left');
  my $lopc = $fop->Label(-text => 'tape read', -anchor => 'w',
		-background=>'green')->pack(-side=> 'left');
  my $lopd = $fop->Label(-text => 'tape write', -anchor => 'w',
		-background=>'lightblue')->pack(-side=> 'left');

  #drive #0
  my $f1 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'top', -pady=>10);
  my $f11 = $f1->Frame(-borderwidth => 3, -relief=>'groove', 
		-background=>'white')
		->pack(-side => 'left');
  my $f12 = $f1->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $f13 = $f1->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $l11 = $f11->Label(-text => 'Drive 0', -anchor => 'w',
		-background=>'white') ->pack(-side=> 'top');
  $b11_drv0 = $f11->Button( -text => $d0tape, -background => 'grey',
		-relief => 'sunken', -command => [\&Mt_stat, 0],)
		->pack(-side=> 'top', -pady => 10);

  my $l13 = $f13->Label(-text => 'Qentry', -anchor => 'n')
		->pack(-side=> 'top', -pady=>0);
  my $b13 = $f13->Button( -text => '------------', -background => 'grey',
	-height=>1, -width=>24, -relief => 'sunken', -command => \&Exit_sub,)
		->pack(-side=> 'top', -padx=>4, -pady => 8);

  my $fcmd0 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
                ->pack(-side => 'top', -pady=>0);
  my $lcmd0 = $fcmd0->Label(-text => 'Drive 0 cmd:', -anchor => 'w')
		->pack(-side=> 'left', -pady=>0);
  #my $tcmd0 = $fcmd0->Text(qw/-width 60 -height 2/)->pack(-side=>'left');
  my $tcmd0 = $fcmd0->Scrolled("Text", -scrollbars=> "e", 
		qw/-width 60 -height 0/) ->pack(-side=>'left');
  $tcmd0->insert('end', "this will be Drive 0 cmds\n");
  $tcmd0->bindtags(undef);

  #drive #1
  my $f2 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'top', -pady=>10);
  my $f21 = $f2->Frame(-borderwidth => 3, -relief=>'groove',
		-background=>'white')
		->pack(-side => 'left');
  my $f22 = $f2->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $f23 = $f2->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $l21 = $f21->Label(-text => 'Drive 1', -anchor => 'w',
		-background=>'white') ->pack(-side=> 'top');
  $b21_drv1 = $f21->Button( -text => $d1tape, -background => 'grey',
		-relief => 'sunken', -command => [\&Mt_stat, 1],)
		->pack(-side=> 'top', -pady => 10);

  my $l23 = $f23->Label(-text => 'Qentry', -anchor => 'n')
		->pack(-side=> 'top', -pady=>0);
  my $b23 = $f23->Button( -text => '------------', -background => 'grey',
	-height=>1, -width=>24, -relief => 'sunken', -command => \&Exit_sub,)
		->pack(-side=> 'top', -padx=>4, -pady => 8);
  my $fcmd1 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
                ->pack(-side => 'top', -pady=>0);
  my $lcmd1 = $fcmd1->Label(-text => 'Drive 1 cmd:', -anchor => 'w')
		->pack(-side=> 'left', -pady=>0);
  my $tcmd1 = $fcmd1->Scrolled("Text", -scrollbars=> "e", 
		qw/-width 60 -height 2/) ->pack(-side=>'left');
  $tcmd1->insert('1.0', "this will be Drive 1 cmds\n");
  $tcmd1->bindtags(undef);

  #drive #2
  my $f3 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'top', -pady=>10);
  my $f31 = $f3->Frame(-borderwidth => 3, -relief=>'groove',
		-background=>'white')
		->pack(-side => 'left');
  my $f32 = $f3->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $f33 = $f3->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $l31 = $f31->Label(-text => 'Drive 2', -anchor => 'w',
		-background=>'white') ->pack(-side=> 'top');
  $b31_drv2 = $f31->Button( -text => $d2tape, -background => 'grey',
		-relief => 'sunken', -command => [\&Mt_stat, 2],)
		->pack(-side=> 'top', -pady => 10);

  my $l33 = $f33->Label(-text => 'Qentry', -anchor => 'n')
		->pack(-side=> 'top', -pady=>0);
  my $b33 = $f33->Button( -text => '------------', -background => 'grey',
	-height=>1, -width=>24, -relief => 'sunken', -command => \&Exit_sub,)
		->pack(-side=> 'top', -padx=>4, -pady => 8);

  my $fcmd2 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
                ->pack(-side => 'top', -pady=>0);
  my $lcmd2 = $fcmd2->Label(-text => 'Drive 2 cmd:', -anchor => 'w')
		->pack(-side=> 'left', -pady=>0);
  my $tcmd2 = $fcmd2->Scrolled("Text", -scrollbars=> "e", 
		qw/-width 60 -height 2/) ->pack(-side=>'left');
  $tcmd2->insert('1.0', "this will be Drive 2 cmds\n");
  $tcmd2->bindtags(undef);

  #drive #3
  my $f4 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'top', -pady=>10);
  my $f41 = $f4->Frame(-borderwidth => 3, -relief=>'groove',
		-background=>'white')
		->pack(-side => 'left');
  my $f42 = $f4->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $f43 = $f4->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
  my $l41 = $f41->Label(-text => 'Drive 3', -anchor => 'w',
		-background=>'white') ->pack(-side=> 'top');
  $b41_drv3 = $f41->Button( -text => $d3tape, -background => 'grey',
		-relief => 'sunken', -command => [\&Mt_stat, 3],)
		->pack(-side=> 'top', -pady => 10);

  my $l43 = $f43->Label(-text => 'Qentry', -anchor => 'n')
		->pack(-side=> 'top', -pady=>0);
  my $b43 = $f43->Button( -text => '------------', -background => 'grey',
	-height=>1, -width=>24, -relief => 'sunken', -command => \&Exit_sub,)
		->pack(-side=> 'top', -padx=>4, -pady => 8);

  my $fcmd3 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
                ->pack(-side => 'top', -pady=>0);
  my $lcmd3 = $fcmd3->Label(-text => 'Drive 3 cmd:', -anchor => 'w')
		->pack(-side=> 'left', -pady=>0);
  my $tcmd3 = $fcmd3->Scrolled("Text", -scrollbars=> "e", 
		qw/-width 60 -height 2/) ->pack(-side=>'left');
  $tcmd3->insert('1.0', "this will be Drive 3 cmds\n");
  $tcmd3->bindtags(undef);

   #now the Rd and Wt queues
   $fq3 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'top', -pady=>20);
   $fq31 = $fq3->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
   $fq32 = $fq3->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'left');
   $l31 = $fq31->Label(-text => 'Rd Q', -anchor => 'w')
  		->pack(-side=> 'top');
   for($i=0; $i < $MAX_Q_ENTIRES; $i++) {
     $x = "\$brdq$i = \$fq31->Button( -text => '------------', 
	-background => 'grey', -height=>1, -width=>24, -relief => 'sunken', 
	-command => \\&Exit_sub,) ->pack(-side=> 'top', -padx=>4)";
     eval($x);
   }
   $brdq_ix = 0;		#index of next position to update

   $l32 = $fq32->Label(-text => 'Wt Q', -anchor => 'w')
		->pack(-side=> 'top');
   for($i=0; $i < $MAX_Q_ENTIRES; $i++) {
     $x = "\$bwtq$i = \$fq32->Button( -text => '------------', 
	-background => 'grey', -height=>1, -width=>24, -relief => 'sunken', 
	-command => \\&Exit_sub,) ->pack(-side=> 'top', -padx=>4)";
     eval($x);
   }
   $bwtq_ix = 0;		#index of next position to update

  #now the robot commands
  my $fr4 = $mw->Frame(-borderwidth => 0, -relief=>'flat')
		->pack(-side => 'bottom', -pady=>0);
  my $lr = $fr4->Label(-text => 'Robot0 cmd:', -anchor => 'w')
		->pack(-side=> 'left', -pady=>0);
  #my $trobot0 = $fr4->Text(qw/-width 60 -height 2/)->pack(-side=>'left');
  my $trobot0 = $fr4->Scrolled("Text", -scrollbars=> "e",
                qw/-width 60 -height 0/) ->pack(-side=>'left');
  $trobot0->insert('end', "this will be robot0 cmd\n");
  $trobot0->bindtags(undef);

  $mw->bind('all', '<Control-c>' => \&Exit_sub);
  #$mw->bind('all', '<Destroy>' => \&exit);#No, will exit incorrectly
  $mw->afterCancel($log_track);
  if(!$playback) {
    $log_track = $mw->repeat(1000, \&log_update); #update every 1.0 sec
  }
  else {
    $log_track = $mw->repeat(2000, \&log_update); #introduce delay for playb
  }

MainLoop;

###########################################################################

#Called every second to get any new queue, robot, or drive activity.
#If playback mode, wait 5 secs after each active line found.
sub log_update {
  my $new_file = "/usr/local/logs/SUM/sum_restart_$$.touch";
  if((-e $new_file) && !$playback) {    #sum_svc tells us to restart
    `/bin/rm -f $new_file`;
    my $lopened = 0;
    system "/bin/rm $runtag";
    print "$OURPATH is exiting and restarting...\n";
    if($interactive) {
      $cmd = "kill $$; $OURPATH -i -r -H$hostdb $DB";
    } 
    else {
      $cmd = "kill $$; $OURPATH -H$hostdb $DB";
    }
    system($cmd);
  }
  if(!$lopened) {       #ignore this part if already opened
    if(!open(LOGL, $tapelog)) {
      print "Can't open $tapelog: $!\n";
      system "/bin/rm $runtag";
      exit;
    }
    $lopened = 1;
  }
  seek(LOGL, 0, 1);
  while(<LOGL>) {
    if(/^\*Tp:RdQsort:/) {      #rd Q may have been reordered
      $bix = 0;
      while(1) {
        if($bix < $MAX_Q_ENTIRES) {
          $x = "\$brdq$bix->configure(-text => '------------')";
          eval($x);
          $bix++;
        }
        else { last; }
      }
      $brdq_ix = 0;
      %Hofrdq = ();             #reinit
    }
    elsif(/^\*Tp:RdQadd:/) {
      ($a, $uidstr, $tapeidstr, $fnumstr, $userstr, $dxstr) = split(/ /, $_);
      ($a, $uid) = split(/=/, $uidstr);
      ($a, $tid) = split(/=/, $tapeidstr);
      ($a, $filenum) = split(/=/, $fnumstr);
      ($a, $user) = split(/=/, $userstr);
      ($a, $dsix) = split(/=/, $dxstr);
      chomp($dsix);
      $newtxt = "$tid $filenum $user $dsix";
      $Hofrdq{$dsix} = $newtxt;		#!!TBD ck for dups of $dsix?
      $x = "\$brdq$brdq_ix->configure(-text => \$newtxt)";
      eval($x);
      $brdq_ix++;
      if($playback) { last; }
    }
    elsif(/^\*Tp:RdQdel:/) {
      ($a, $dsixstr, $drvstr) = split(/ /, $_);
      ($a, $dsix) = split(/=/, $dsixstr);
      ($a, $dnum) = split(/=/, $drvstr);
      chomp($dnum);
      $txt = $Hofrdq{$dsix};
      if($dnum == 0) {
        $b13->configure(-text => $txt);
      }
      elsif($dnum == 1) {
        $b23->configure(-text => $txt);
      }
      elsif($dnum == 2) {
        $b33->configure(-text => $txt);
      }
      elsif($dnum == 3) {
        $b43->configure(-text => $txt);
      }
      else {			#it's an error msg 
        print "$dnum\n";
      }
      delete($Hofrdq{$dsix});
      @inorder = keys %Hofrdq;          #any keys in order of insert
      $bix = 0;
      while($ix = shift(@inorder)) {
        $txt = $Hofrdq{$ix};
        $x = "\$brdq$bix->configure(-text => \$txt)";
        eval($x);
        $bix++;
      }
      $brdq_ix = $bix;
      while(1) {
        if($bix < $MAX_Q_ENTIRES) {
          $x = "\$brdq$bix->configure(-text => '------------')";
          eval($x);
          $bix++;
        }
        else { last; }
      }
      if($playback) { last; }
    }
    elsif(/^\*Tp:Need:/) {
      ($a, $tapeidstr, $b) = split(/ /, $_);
      ($a, $tid) = split(/=/, $tapeidstr);
      if(!$Hofneed{$tid}) {
        $Hofneed{$tid} = 1;	#save tape as needed
        $EEcnt++;
      }
      $b0text = "Imp/Exp\n$EEcnt";
      $b0->configure(-text => $b0text, -background => 'yellow' );
@needorder = keys %Hofneed;          #any keys in order of insert
print "needorder is:\n@needorder\n";  #!!TEMP
    }
    elsif(/^\*Tp:WtQadd:/) {
      ($a, $uidstr, $tapeidstr, $fnumstr, $userstr, $dxstr) = split(/ /, $_);
      ($a, $uid) = split(/=/, $uidstr);
      ($a, $tid) = split(/=/, $tapeidstr);
      ($a, $filenum) = split(/=/, $fnumstr);
      ($a, $user) = split(/=/, $userstr);
      ($a, $dsix) = split(/=/, $dxstr);
      chomp($dsix);
      $newtxt = "$tid $filenum $user $dsix";
      $Hofwtq{$dsix} = $newtxt;		#!!TBD ck for dups of $dsix?
      $x = "\$bwtq$bwtq_ix->configure(-text => \$newtxt)";
      eval($x);
      $bwtq_ix++;
      if($playback) { last; }
    }
    elsif(/^\*Tp:WtQdel:/) {
      ($a, $dsixstr, $drvstr) = split(/ /, $_);
      ($a, $dsix) = split(/=/, $dsixstr);
      ($a, $dnum) = split(/=/, $drvstr);
      chomp($dnum);
      $txt = $Hofwtq{$dsix};
      if(index($dnum, "*WRN") == -1) {	#if found don't update drv Q display
        if($dnum == 0) {
          $b13->configure(-text => $txt);
        }
        elsif($dnum == 1) {
          $b23->configure(-text => $txt);
        }
        elsif($dnum == 2) {
          $b33->configure(-text => $txt);
        }
        elsif($dnum == 3) {
          $b43->configure(-text => $txt);
        }
        else {			#it's an error msg 
          print "$dnum\n";
        }
      }
      delete($Hofwtq{$dsix});
      @inorder = keys %Hofwtq;          #any keys in order of insert
      $bix = 0;
      while($ix = shift(@inorder)) {
        $txt = $Hofwtq{$ix};
        $x = "\$bwtq$bix->configure(-text => \$txt)";
        eval($x);
        $bix++;
      }
      $bwtq_ix = $bix;
      while(1) {
        if($bix < $MAX_Q_ENTIRES) {
          $x = "\$bwtq$bix->configure(-text => '------------')";
          eval($x);
          $bix++;
        }
        else { last; }
      }
      if($playback) { last; }
    }
    elsif(/^\*Tp:BulkLoadDone/) {
      if(Exists($ImpExpf)) {		#this is in case tui restarts
        $ImpExpf->destroy();
        @needorder = ();
        $EEcnt = 0;
        $b0text = "Imp/Exp\n$EEcnt";
        $b0->configure(-text => $b0text, -background => 'grey',
		-command =>  \&ImpExp_sub,); 
      }
      if(!$interactive) {
        $EEcnt = 0;
        $b0text = "Imp/Exp\n$EEcnt";
        $b0->configure(-text => $b0text, -background => 'grey',
		-command =>  \&ImpExp_sub,); 
      }
    }
    elsif(/^\*Rb:door:/) {		#a imp/exp door transfer cmd
      $str = substr($_, 10);
      $trobot0->insert('end', $str);
      $trobot0->see('end');
      ($a,$b,$dev,$com,$sslot,$dslot) = split(/ /, $str);
      $x = "\$slotbt$sslot->configure(-background => 'yellow')";
      eval($x);
      $x = "\$slotbtx$dslot->configure(-background => 'yellow')";
      eval($x);
    }
    elsif((/^\*\*Rb:doorsuccess/) || (/^\*\*Rb:doorfailure/)) {
      $x = "\$slotbt$sslot->configure(-background => 'grey',
			-text=>'$slottapes[$dslot-1]')";
      eval($x);
      $y = $slottapes[$sslot-1];
      $slottapes[$sslot-1] = $slottapes[$dslot-1];
      $slottapes[$dslot-1] = $y;
      $x = "\$slotbtx$dslot->configure(-background => 'grey',
			-text=>\$y)";
      eval($x);
    }
    elsif(/^\*\*Rb:doorcomplete/) {
      #the Expired tapes have been unloaded. resume the imp/exp operations
      if($interactive) { &Imp_Exp_Open_Door; }
    }
    elsif(/^\*Rb:cmd:/) {		#a tape robot cmd 
      $str = substr($_, 9);
      chomp($str);
      $trobot0->insert('end', $str);
      $trobot0->see('end');
      ($a,$b,$dev,$com,$snum,$rbdnum) = split(/ /, $str);
      $x = "\$slotbt$snum->configure(-background => 'yellow')";
      eval($x);
      if($com eq "load") {		#loading tape to a drive
        delete($Hofreplace{$slottapes[$snum-1]}); #not eligible for replace
      }
      elsif($com eq "unload") {		#unloading tape from a drive
        $x = eval("\$d".$rbdnum."tape");
        $Hofreplace{$x} = 1;		#eligible for replace again
      }
      if($rbdnum == 0) {
        $b11_drv0->configure(-background => 'yellow');
      }
      elsif($rbdnum == 1) {
        $b21_drv1->configure(-background => 'yellow');
      }
      elsif($rbdnum == 2) {
        $b31_drv2->configure(-background => 'yellow');
      }
      elsif($rbdnum == 3) {
        $b41_drv3->configure(-background => 'yellow');
      }
      if($playback) { last; }
    }
    elsif(/^\*\*\*Rb:/) {
      $trobot0->insert('end', $_);
      if($rbdnum == 0) {
        $b11_drv0->configure(-background=>'grey', -text=>$slottapes[$snum-1]);
        $x = "\$slotbt$snum->configure(-background=>'grey',-text=>\$d0tape)";
        eval($x);
        $y = $d0tape;
        $d0tape = $slottapes[$snum-1];
        $slottapes[$snum-1] = $y;
      }
      elsif($rbdnum == 1) {
        $b21_drv1->configure(-background=>'grey', -text=>$slottapes[$snum-1]);
        $x = "\$slotbt$snum->configure(-background=>'grey',-text=>\$d1tape)";
        eval($x);
        $y = $d1tape;
        $d1tape = $slottapes[$snum-1];
        $slottapes[$snum-1] = $y;
      }
      elsif($rbdnum == 2) {
        $b31_drv2->configure(-background=>'grey', -text=>$slottapes[$snum-1]);
        $x = "\$slotbt$snum->configure(-background=>'grey',-text=>\$d2tape)";
        eval($x);
        $y = $d2tape;
        $d2tape = $slottapes[$snum-1];
        $slottapes[$snum-1] = $y;
      }
      elsif($rbdnum == 3) {
        $b41_drv3->configure(-background=>'grey', -text=>$slottapes[$snum-1]);
        $x = "\$slotbt$snum->configure(-background=>'grey',-text=>\$d3tape)";
        eval($x);
        $y = $d3tape;
        $d3tape = $slottapes[$snum-1];
        $slottapes[$snum-1] = $y;
      }
      #if($playback) { last; }
    }
    elsif(/^\*Inv:/) {			#an inventory cmd
      $str = substr($_, 6, 33);
      $trobot0->insert('end', "$str\n");
      $trobot0->see('end');
      foreach $i (1 .. $MAX_SLOTS) {	#turn all slots yellow
        $x = "\$slotbt$i->configure(-background => 'yellow',-text=>'-------------')";
        eval($x);
      }
      #always go away to give time to see the display change
      last;
      #if($playback) { last; }
    }
    elsif(/^\*\*\*Inv:/) {
      $trobot0->insert('end', $_);
      foreach $i (1 .. $MAX_SLOTS) {	#turn all slots grey
        $x = "\$slotbt$i->configure(-background => 'grey')";
        eval($x);
      }
      &show_tape_in_slots;		#display where tapes are
      if($playback) { last; }
    }
    elsif(/^\*Dr0:rd:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd0->insert('end', "$str\n");
      $tcmd0->see('end');
      $b11_drv0->configure(-background => 'green');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr0:rd:/) {
      $tcmd0->insert('end', $_);
      $b11_drv0->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr1:rd:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd1->insert('end', "$str\n");
      $tcmd1->see('end');
      $b21_drv1->configure(-background => 'green');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr1:rd:/) {
      $tcmd1->insert('end', $_);
      $b21_drv1->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr2:rd:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd2->insert('end', "$str\n");
      $tcmd2->see('end');
      $b31_drv2->configure(-background => 'green');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr2:rd:/) {
      $tcmd2->insert('end', $_);
      $b31_drv2->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr3:rd:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd3->insert('end', "$str\n");
      $tcmd3->see('end');
      $b41_drv3->configure(-background => 'green');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr3:rd:/) {
      $tcmd3->insert('end', $_);
      $b41_drv3->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr0:wt:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd0->insert('end', "$str\n");
      $tcmd0->see('end');
      $b11_drv0->configure(-background => 'lightblue');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr0:wt:/) {
      $tcmd0->insert('end', $_);
      $b11_drv0->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr1:wt:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd1->insert('end', "$str\n");
      $tcmd1->see('end');
      $b21_drv1->configure(-background => 'lightblue');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr1:wt:/) {
      $tcmd1->insert('end', $_);
      $b21_drv1->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr2:wt:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd2->insert('end', "$str\n");
      $tcmd2->see('end');
      $b31_drv2->configure(-background => 'lightblue');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr2:wt:/) {
      $tcmd2->insert('end', $_);
      $b31_drv2->configure(-background=>'grey');
      if($playback) { last; }
    }
    elsif(/^\*Dr3:wt:/) {
      $str = substr($_, 9);
      $pos = index($str, "1>");
      $str = substr($str, 0, $pos);
      $tcmd3->insert('end', "$str\n");
      $tcmd3->see('end');
      $b41_drv3->configure(-background => 'lightblue');
      if($playback) { last; }
    }
    elsif(/^\*\*\*Dr3:wt:/) {
      $tcmd3->insert('end', $_);
      $b41_drv3->configure(-background=>'grey');
      if($playback) { last; }
    }
  }
}

#######################################################################
#Open the log file and show the results of the inventory for which
#tapes are in which slots and drives.
#
sub show_tape_in_slots {
  $row = $column = $slnum = $freeslots = $tapesindrives = 0;
  $rows_per_col = 24;
  @slottapes = ();
  @emptyslottapes = ();
  while(<LOGL>) {
    if(/^\*\*\*ENDInv:/) { last; }
    if(/^tapeid in drive 0/) {
      $pos = index($_, "0 = ");
      $d0tape = substr($_, $pos+4);
      chomp($d0tape);
      if($d0tape eq "(null)") {
        $d0tape = "-------------";
      }
      else {
        $d0tape = "$d0tape  ";	#2 extra spaces needed here
        $tapesindrives++;
      }
    }
    if(/^tapeid in drive 1/) {
      $pos = index($_, "1 = ");
      $d1tape = substr($_, $pos+4);
      chomp($d1tape);
      if($d1tape eq "(null)") {
        $d1tape = "-------------";
      }
      else {
        $d1tape = "$d1tape  ";	#2 extra spaces needed here
        $tapesindrives++;
      }
    }
    if(/^tapeid in drive 2/) {
      $pos = index($_, "2 = ");
      $d2tape = substr($_, $pos+4);
      chomp($d2tape);
      if($d2tape eq "(null)") {
        $d2tape = "-------------";
      }
      else {
        $d2tape = "$d2tape  ";	#2 extra spaces needed here
        $tapesindrives++;
      }
    }
    if(/^tapeid in drive 3/) {
      $pos = index($_, "3 = ");
      $d3tape = substr($_, $pos+4);
      chomp($d3tape);
      if($d3tape eq "(null)") {
        $d3tape = "-------------";
      }
      else {
        $d3tape = "$d3tape  ";	#2 extra spaces needed here
        $tapesindrives++;
      }
    }
    if(/^tapeid in slot/) {
      $pos = index($_, " = ");
      $stape = substr($_, $pos+3);
      chomp($stape);
      if(index($stape, "null") != -1) {
        if(($pos = index($stape, "drive #")) != -1) {
          $indrv = substr($stape, $pos+7);
          chomp($indrv);
          $x = "\$stape = \$d$indrv"."tape";
          eval($x);
          push(@emptyslottapes, $stape);
        }
        $stape = "-------------";
        if($slnum < $MAX_SLOTS) {       #don't count tapes in EE slots
          $freeslots++;
        }
      }
      else {
        if($slnum < $MAX_SLOTS) {	#don't count tapes in EE slots
          $Hofreplace{$stape} = 1;	#tape eligible to be replaced
        }
      }
      $slnum++;
      push(@slottapes, $stape);
    }
  }
  $freeslots = $freeslots - $tapesindrives; # #of slots not assigned
  print "#of slots with no assignment = $freeslots\n"; #!!TEMP
  #init drive slots button text
  $b11_drv0->configure(-background=>'grey', -text=>$d0tape);
  $b21_drv1->configure(-background=>'grey', -text=>$d1tape);
  $b31_drv2->configure(-background=>'grey', -text=>$d2tape);
  $b41_drv3->configure(-background=>'grey', -text=>$d3tape);
  #init queue text
  $b13->configure(-text => '------------');
  $b23->configure(-text => '------------');
  $b33->configure(-text => '------------');
  $b43->configure(-text => '------------');
  foreach $i (1 .. $MAX_SLOTS) {
    #$tapeid = shift(@slottapes);
    $tapeid = $slottapes[$i-1];
    if($tapeid eq "-------------") {
      $tapeidinfo = shift(@emptyslottapes);
    }
    else {
      $tapeidinfo = $tapeid;
    }
    $y = "\$slotbt$i";
    $x = "\$slotbt$i->configure(-text => \$tapeid, 
		-command => \[\\&Tape_info, \$tapeidinfo\])";
#    $x = "\$slotbt$i = \$f0->Button(
#        -text => \$tapeid,
#        -background => 'grey',
#        -relief => 'sunken',
#        -command => \[\\&Tape_info, \$tapeid\],
#        )";
     eval($x);
#    $txt = "      ".$i;
#    my $l = $f0->Label(-text => $txt, -anchor => 'w', -justify => 'left');
#    Tk::grid( $l, -row => $row, -column => $column, 
#		-sticky => 'nw', -pady => 1);
#    Tk::grid( eval($y), -row => $row, -column => ($column+1),
#		-sticky => 'w', -pady => 1);
#    $f0->gridRowconfigure($row++,-weight => 0);
#    $f0->gridColumnconfigure($column,-weight => 1, -minsize => 10);
#    $f0->gridColumnconfigure($column+1,-weight => 8, -minsize => 10);
    if($row == $rows_per_col) { $row = 0; $column += 2; }
  }
}

sub show_notape_in_slots {
  $row = 0; $column = 0; $rows_per_col = 24;
  foreach $i (1 .. $MAX_SLOTS) {
    $tapeid = "-------------";
    $y = "\$slotbt$i";
    $x = "\$slotbt$i = \$f0->Button(
        -text => \$tapeid,
        -background => 'grey',
        -relief => 'sunken',
        -command => \\&Exit_sub,
        )";
     eval($x);
    $txt = "      ".$i;
    my $l = $f0->Label(-text => $txt, -anchor => 'w', -justify => 'left');
    Tk::grid( $l, -row => $row, -column => $column, 
		-sticky => 'nw', -pady => 2);
    Tk::grid( eval($y), -row => $row, -column => ($column + 1),
		-sticky => 'w', -pady => 2);
    $f0->gridRowconfigure($row++,-weight => 0);
    $f0->gridColumnconfigure($column,-weight => 1, -minsize => 10);
    $f0->gridColumnconfigure($column+1,-weight => 8, -minsize => 10);
    if($row == $rows_per_col) { $row = 0; $column += 2; }
  }
}

sub show_notape_in_slots_impexp {
  my $row = 0; $column = 0;
  foreach $i (($MAX_SLOTS + 1) .. ($MAX_SLOTS + $NUM_IMP_EXP_SLOTS)) {
    $tapeid = "-------------";
    $y = "\$slotbtx$i";
    $x = "\$slotbtx$i = \$f00->Button(
        -text => \$tapeid,
        -background => 'grey',
        -relief => 'sunken',
        -command => \\&Exit_sub,
        )";
     eval($x);
    $txt = "      ".$i;
    my $l = $f00->Label(-text => $txt, -anchor => 'w', -justify => 'left');
    Tk::grid( $l, -row => $row, -column => $column, 
		-sticky => 'nw', -pady => 2);
    Tk::grid( eval($y), -row => $row, -column => ($column + 1),
		-sticky => 'w', -pady => 2);
    $f00->gridRowconfigure($row++,-weight => 0);
    $f0->gridColumnconfigure($column,-weight => 1, -minsize => 10);
  }

  #put in tapeid's:
  foreach $i (($MAX_SLOTS + 1) .. ($MAX_SLOTS + $NUM_IMP_EXP_SLOTS)) {
    $tapeid = $slottapes[$i-1];
    if($tapeid eq "-------------") {
      $tapeidinfo = shift(@emptyslottapes);
    }
    else {
      $tapeidinfo = $tapeid;
    }
    $y = "\$slotbtx$i";
    $x = "\$slotbtx$i->configure(-text => \$tapeid,
                -command => \[\\&Tape_info, \$tapeidinfo\])";
     eval($x);
  }
}
#######################################################################

#Called from the Imp/Exp button on the top level page.
sub ImpExp_sub {
  if(Exists($ImpExpf)) {
    $ImpExpf->destroy();
  }
  $ImpExpf = $mw->Toplevel();
  #$ImpExpf->geometry("590x400+25+500");
  $ImpExpf->geometry("590x340");
  $ImpExpf->title("Import/Export Ops");
  $ImpExpf->Button(
        -text => 'Close',
        -background => 'grey',
        -command => sub {$ImpExpf->destroy();},
        )->pack();

  if(!$interactive) {
    $msg = "\nSorry, you are not the interactive user. You cannot do Imp/Exp.";
    $ImpExpf->Label(-text => $msg, -font => 'arial 12 bold')->pack(@pl);
    return;
  }
  #Old LRU method no longer used. Now use group_table effective_date.
  #@torder = keys %Hofreplace;  #tapeid in LRU order
  @needorder =  keys %Hofneed; #needed tapeid in order requested
  $numneed = $#needorder+1;
  if($numneed == 0) {
    $ImpExpf->Label(-text => "No tapes needed\n", -font => 'arial 12 bold')->pack(@pl);
    return;
  }
  if($numneed > $NUM_IMP_EXP_SLOTS) { 
    $numneed = $NUM_IMP_EXP_SLOTS;	#only this many slots in the door
  }
  #Return expired tapeid's in @exptape
  &get_exp_tapes;
  $numexp = $#exptape+1;
  if($numexp < $numneed) {
    $msg = "Only $numexp tapes have retention time expired. Needed $numneed\n";
    $ImpExpf->Label(-text => $msg, -font => 'arial 12 bold')->pack(@pl);
    $msg = "We will unload $numexp tapes. Change effective_date in DB to unload more tapes. \n";
    $ImpExpf->Label(-text => $msg, -font => 'arial 12 bold')->pack(@pl);
    $numneed = $numexp;
  }
  $msg = "NOTE: We will unload $numneed tape(s). Click below to start unload of expired tapes\n";
  $ImpExpf->Label(-text =>$msg, -font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Button(
            -text => 'Start Expired Tape Unload',
            -background => 'red',
            -command =>  \&ImpExp_sub_unload,
            )->pack();
}

#Called when the "Start Expired Tape Unload" button (defined in ImpExp_sub) is hit.
sub ImpExp_sub_unload {
  if(Exists($ImpExpf)) {
    $ImpExpf->destroy();
  }
  $ImpExpf = $mw->Toplevel();
  #$ImpExpf->geometry("590x400+25+500");
  $ImpExpf->geometry("590x340");
  $ImpExpf->title("Import/Export Ops");
  $ImpExpf->Button(
        -text => 'Close',
        -background => 'grey',
        -command => sub {$ImpExpf->destroy();},
        )->pack();

    $ImpExpf->Label(-text=> "Unload of Expired Tapes In Progress (I will notify you when done)", 
		 -background=>'orange', -font => 'arial 12 bold')->pack(@pl);
    $ImpExpf->Label(-text => "Exit/Entry Slots in Door:", 
		 -font => 'arial 12 bold')->pack(@pl);
    #@txorder = @torder;
    @txorder = @exptape;
    @unloadids = ();
    $IE0 = $ImpExpf->Frame(-borderwidth => 0) ->pack(-side => 'left');
    $IE0->Label(-text => "Tapes to unload:", 
		-font => 'arial 12 bold')->pack(@pl);
    for($i=0; $i < $numneed; $i++) {
      $tpid = shift(@txorder);
      push(@unloadids, $tpid);
      delete($Hofreplace{$tpid});	#remove this tape from the hash
      $IE0->Label(-text => $tpid, 
		-background=>'orange', -font => 'arial 12 bold')->pack(@pl);
    }
    $f00 = $ImpExpf->Frame(-borderwidth => 3, -relief=>'groove')
  		->pack(-side => 'left');
    &show_notape_in_slots_impexp;	#show blank tape slots
    $f00f = $ImpExpf->Frame(-borderwidth => 0) ->pack(-side => 'left');
    $f00f->Label(-text => "(NOTE!! Only use this force button\nif you previously hit Bulk Load Done\nprematurely and the unload is already done)", -font => 'arial 12 bold')->pack(@pl);
    $f00f->Button(
            -text => 'Force',
            -background => 'red',
            -command =>  \&Imp_Exp_Open_Door,
            )->pack();

      if($pid0 = fork) {
        #This is the parent. The child's pid is in $pid0
        print LOG "          \n";	#!!don't lose first few chars on line??
        print LOG "fork impexp start processing pid=$pid0 for impexp.\n";
      } elsif (defined $pid0) {     # $pid0 is zero here if defined. run impexp
        exec "impexp start @unloadids";
      }  else {
        #fork error
        $ImpExpf->Label(-text => "Fatal Error: Can't fork", -font => 'arial 12 bold')->pack(@pl);
        print "!!Fatal Error: Can't fork: $!\n";
      }
}

#Called from log_update() when Rb:doorcomplete occurs.
#The Expired tapes have been put into the imp/exp door and we are now ready to
#open the door and remove the old tapes and put in the new required tapes
#and do a bulk load to load the new tapes into the live slots.
sub Imp_Exp_Open_Door {
  if(Exists($ImpExpf)) {
    $ImpExpf->destroy();
  }
  $ImpExpf = $mw->Toplevel();
  #$ImpExpf->geometry("590x400+25+500");
  $ImpExpf->geometry("590x480");
  $ImpExpf->title("Import/Export Ops");
  $ImpExpf->Button(
        -text => 'Close',
        -background => 'grey',
        -command => sub {$ImpExpf->destroy();},
        )->pack();
  #reset the command sub on the Imp/Exp button on the main page to come here
  $b0->configure(-text => $b0text, -background => 'yellow',
		-command =>  \&Imp_Exp_Open_Door,); 
  $ImpExpf->Label(-text => "NOTE: Expired tapes have been unloaded.", 
		-font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Label(-text => "Now complete each step in the order given:", 
		-font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Label(-text => "Go to the t120 console and hit Import/Export >>Bulk Load.", 
		-font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Label(-text=>"The door will open - remove any tapes in the door and insert the needed tapes.", 
		-font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Label(-text => "Need tapes:", 
  		-font => 'arial 12 bold')->pack(@pl);
  @xneedorder = @needorder;
  $numneed = $#needorder+1;
  $EEcnt_new = 0;
  if($numneed > $NUM_IMP_EXP_SLOTS) { 
    $EEcnt_new = $numneed - $NUM_IMP_EXP_SLOTS;
    $numneed = $NUM_IMP_EXP_SLOTS;	#only this many slots in the door
  }
  for($i=0; $i < $numneed; $i++) {
    $tid = shift(@xneedorder);
    $ImpExpf->Label(-text => $tid, 
  		-background=>'orange', -font => 'arial 12 bold')->pack(@pl);
    delete($Hofneed{$tid});	#remove this tape as needed from the hash
  }
  $ImpExpf->Label(-text=>"When these tapes are in the EE slots, hit Continue.", 
		-font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Label(-text => "When the tape load is complete hit Finished.", 
		-font => 'arial 12 bold')->pack(@pl);
  $msg = "When bulk load is finished, hit the done button below:\n";
  $ImpExpf->Label(-text => $msg, 
		-font => 'arial 12 bold')->pack(@pl);
  $msg = "(NOTE: when hit below, there will be a delay for a new inventory)\n";
  $ImpExpf->Label(-text => $msg, 
		-font => 'arial 12 bold')->pack(@pl);
  $ImpExpf->Button(
        -text => 'Bulk Load Done',
        -background => 'red',
        -command => \&Bulk_Load_Done,
        )->pack();
}

#Called from Imp_Exp_Open_Door() button "Bulk Load Done". The operator has
#indicated that the needed tapes have been loaded into the live slots and
#were ready to take a new inventory and resume normal operations.
sub Bulk_Load_Done {
  @needorder = ();
  $EEcnt = $EEcnt_new;
  $b0text = "Imp/Exp\n$EEcnt";
  $b0->configure(-text => $b0text, -background => 'grey',
		-command =>  \&ImpExp_sub,); 
  if($pid0 = fork) {
    #This is the parent. The child's pid is in $pid0
    print LOG "          \n";	#!!don't lose first few chars on line??
    print LOG "fork impexp stop processing pid=$pid0 for impexp.\n";
  } elsif (defined $pid0) {     # $pid0 is zero here if defined. run impexp
    exec "impexp stop @unloadids";
  }  else {
    #fork error
    print "!!Error: Can't fork: $!\n";
  }
  sleep 5;			#allow impexp to run
  if(Exists($ImpExpf)) {
    $ImpExpf->destroy();
  }
  &show_tape_in_slots;
}

#Get tapes that are past the effective_date for their group, as defined in the
#sum_group table in ascending effective_date order.
#Return the tapeid's in @exptape.
sub get_exp_tapes{
  @exptape = ();
  $sqlcmd = "select * from sum_group order by effective_date";
  print "sqlcmd is: $sqlcmd\n\n"; #!!TEMP
  $sth = $dbh->prepare($sqlcmd);
  if ( !defined $sth ) {
    print "Cannot prepare statement: $DBI::errstr\n";
    system "/bin/rm $runtag";
    exit;
  }
  # Execute the statement at the database level
  $sth->execute;
  $date = &get_effdate;
  while(@group_table = $sth->fetchrow()) { #get row from the DB
    if($group_table[2] lt $date) {	#this has expired
      $grp = $group_table[0];
      #print "group=$grp, retain=$group_table[1], eff=$group_table[2]\n";#!!TEMP
      $sqlcmd = "select tapeid from sum_tape where group_id=$grp";
      #print "sqlcmd is: $sqlcmd\n\n"; #!!TEMP
      $sth2 = $dbh->prepare($sqlcmd);
      if ( !defined $sth2 ) {
        print "Cannot prepare statement: $DBI::errstr\n";
        system "/bin/rm $runtag";
        exit;
      }
      # Execute the statement at the database level
      $sth2->execute;
      while(@efftape = $sth2->fetchrow()) { #get row from the DB
        print "efftape = @efftape[0]\n"; #!!TEMP
        if(grep(/@efftape[0]/, @slottapes)) {
          push(@exptape, @efftape[0]);
        }
        else {
          if((index($d0tape, @efftape[0]) != -1) || (index($d1tape,  @efftape[0]) != -1) ||  (index($d2tape,  @efftape[0]) != -1) ||  (index($d3tape,  @efftape[0]) != -1)) {
            push(@exptape, @efftape[0]);
          }
        }
      }
    }
  }
}

#Return effective date of now as yyyymmddhhmm
sub get_effdate {
  local($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst,$date,$sec2,$min2,$hour2,$mday2);
  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
  $min2 = sprintf("%02d", $min);
  $hour2 = sprintf("%02d", $hour);
  $mday2 = sprintf("%02d", $mday);
  $mon2 = sprintf("%02d", $mon+1);
  $year4 = sprintf("%04d", $year+1900);
  $date = "$year4"."$mon2"."$mday2"."$hour2"."$min2";
  return($date);
}

#Return date in form for a label e.g. 1998.01.07_14:42:00
sub labeldate {
  local($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst,$date,$sec2,$min2,$hour2,$mday2);
  ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
  $sec2 = sprintf("%02d", $sec);
  $min2 = sprintf("%02d", $min);
  $hour2 = sprintf("%02d", $hour);
  $mday2 = sprintf("%02d", $mday);
  $mon2 = sprintf("%02d", $mon+1);
  $year4 = sprintf("%04d", $year+1900);
  $date = $year4.".".$mon2.".".$mday2._.$hour2.":".$min2.":".$sec2;
  return($date);
}

#Return time in form for a label e.g. 14:42:00
sub labeltime {
  my $d = &labeldate;
  my $pos = index($d, '_');
  my $t = substr($d, $pos+1);
  return($t);
}

sub Tape_info {
  my($tapeid) = @_;
  chop($tapeid); chop($tapeid); #elim 2 extra spaces
  if(Exists($statf)) {
    $statf->destroy();
  }
  $statf = $mw->Toplevel();
  $statf->geometry("400x200-10-500");
  $statf->title("tape info");
  $txt = "Query of SUM_TAPE_TABLE";
  $statf->Label(-text => "$txt", -font => 'arial 18 bold')->pack();
  $statf->Button(
        -text => 'Close',
        -background => 'grey',
        -command => sub {$statf->destroy();},
        )->pack();
  $textlog = $statf->Scrolled("Text")->pack();
  $sqlcmd = "select TAPEID,NXTWRTFN,SPARE,GROUP_ID,AVAIL_BLOCKS,CLOSED,TO_CHAR(LAST_WRITE, 'dd/MON/yyyy_hh24:mi:ss') from sum_tape where tapeid = \'$tapeid\'";
  #$sqlcmd = "select TAPEID,NXTWRTFN,SPARE,GROUP_ID,AVAIL_BLOCKS,CLOSED,LAST_WRITE from sum_tape where tapeid = \'$tapeid\'";
  #print "sqlcmd is: $sqlcmd\n\n"; #!!TEMP
  $sth = $dbh->prepare($sqlcmd);
  if ( !defined $sth ) {
    print "Cannot prepare statement: $DBI::errstr\n";
    system "/bin/rm $runtag";
    exit;
  }
  # Execute the statement at the database level
  $sth->execute;
  $found = 0;
  while(@data_tape = $sth->fetchrow()) { #get row from the DB
    $found = 1;
    $textlog->insert('end', "Tapeid = $data_tape[0]\n");
    $textlog->insert('end', "Next_Write_File_Number = $data_tape[1]\n");
    $textlog->insert('end', "Spare = $data_tape[2]\n");
    $textlog->insert('end', "Group_Id = $data_tape[3]\n");
    $x = commify($data_tape[4]);
    $textlog->insert('end', "Avail_Blocks = $x\n");
    $textlog->insert('end', "Closed = $data_tape[5]\n");
    $textlog->insert('end', "Last_Write = $data_tape[6]\n");
  }
  if(!$found) {
    $textlog->insert('end', "tapeid = $tapeid not found\n");
  }
  $textlog->see('end');
  $sth->finish;
}

sub Mt_stat {
  my ($drnum) = @_;
  if(Exists($statf)) {
    $statf->destroy();
    close(LOGSTAT);
  }
  $statf = $mw->Toplevel();
  $statf->geometry("400x200-10-500");
  $statf->title("mt");
  $cmd = "mt -f /dev/nst$drnum status";
  $statf->Label(-text => "$cmd", -font => 'arial 18 bold')->pack();
  $statf->Button(
        -text => 'Close',
        -background => 'grey',
        -command => sub {$statf->destroy();},
        )->pack();
  $textlog = $statf->Scrolled("Text")->pack();
  $statlog = "/tmp/Mt_stat.$user.log";
  `$cmd 1> $statlog 2>&1`;
#  $cmd = "mt -f /dev/nst$drnum tell";
#  `$cmd 1>> $statlog 2>&1`;
  if(!open(LOGSTAT, $statlog)) { 
    print "Can't open $statlog: $!\n";
    system "/bin/rm $runtag";
    exit;
  }
  while(<LOGSTAT>) {
    if(/^^File number=/) {
      if(!/^File number=-1/) {	# a tell cmd will hang if drive empty 
        $cmd = "mt -f /dev/nst$drnum tell";
        `$cmd 1>> $statlog 2>&1`;
      }
    }
    $textlog->insert('end', $_);
  }
  $textlog->see('end');
  close(LOGSTAT);
}

sub Exit_sub {
  $dbh->disconnect();
  if($pid0) {			#kill off our child
    `kill $pid0`;
  }
  system "/bin/rm $runtag";
  exit;
}

sub commify {
    my $text = reverse $_[0];
    $text =~ s/(\d\d\d)(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}


