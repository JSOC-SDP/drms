.\"
.TH drms_close_records 3  11-Jan-2007  "DRMS MANPAGE" "DRMS Programmer's Manual"
.SH NAME
drms_close_records \- Close a set of records, optionally inserting new records into the database.

.SH SYNOPSIS
.nf
#include "drms.h"

int drms_close_records(DRMS_RecordSet_t *rs, int action);

.SH DESCRIPTION

If \fIaction\fR == DRMS_FREE_RECORD, then if a record being closed is the only reference to a SUMS storage unit slot, that slot is freed and marked for removal during SUMS garbage collection.  During SUMS garbage collection, all data-segment files stored within this storage unit will be deleted.  In this scenario, segment files written to SUMS during the current DRMS session are not preserved.  If \fIaction\fR == DRMS_INSERT_RECORD, then this function saves the keyword, link, and segment information in the appropriate database tables, and ensures that segment files written to SUMS during the current DRMS session are preserved.  In order to succeed, no record contained in \fIrs\fR can be marked read-only.  

For either action, this function calls drms_free_records() to deallocate the \fIrs\fR DRMS_RecordSet_t structure, the array of pointers to DRMS_Record_t structures contained within \fIrs\fR, and the actual DRMS_Record_t structures that these pointers reference.  All these structures and pointers must have been previously allocated in heap memory (functions like drms_open_records() ensure this is the case).  The records are also removed from the record cache (env->record_cache).

.SH RETURN VALUES
Upon successful completion, the function returns 0.  If an error occurs, the function returns an appropriate error code defined in drms_statuscodes.h.  Typical errors are as follows.  If \fIaction\fR is neither DRMS_FREE_RECORD nor DRMS_INSERT_RECORD, then DRMS_ERROR_INVALIDACTION is returned.  If \fIaction\fR == DRMS_INSERT_RECORD and at least one record in \fIrs\fR is marked read-only, then DRMS_ERROR_COMMITREADONLY is returned.  

.SH EXAMPLES
.nf
#include "drms.h"

DRMS_RecordSet_t *recSet = drms_open_records(drms_env, recSetStr, &status);
     
if (status == 0 && recSet != NULL)
{
     int nRecs = recSet->n;
}

if (recSet != NULL)
{
     drms_close_records(recSet, DRMS_FREE_RECORD);
}

...

DRMS_RecordSet_t *recSetClone = drms_clone_records(recSet, 
                                                   DRMS_PERMANENT, 
                                                   DRMS_SHARE_SEGMENTS, 
                                                   &status);

if (status == 0 && recSetClone != NULL)
{
     /* Do something with recSetClone here. */
}

if (recSetClone != NULL)
{
     drms_close_records(recSetClone, DRMS_INSERT_RECORD);
}

SEE ALSO

drms_closeall_records(3), drms_open_records(3), drms_clone_records(3), drms_retrieve_records(3)
