.\"
.TH drms_segment 3  2007-11-28 "DRMS MANPAGE" "DRMS Programmer's Manual"
.SH NAME
drms_segment \- functions to access DRMS segment data structures
.nf
drms_copy_segment_struct  drms_create_segment_prototypes
drms_delete_segmentfile  drms_free_segment_struct
drms_free_template_segment _struct drms_segment_autoscale
drms_segment_createinfocon  drms_segment_destroyinfocon
drms_segment_filename drms _segment_getblocksize drms_segment_getdims
drms_segment_getscaling  drms_segment_lookup  drms_segment_lookupnum
drms_segment_print  drms_segment _read drms_segment_readslice
drms_segment_segsmatch drms_segment_setblocksize drms_segment_setdims
drms_segment_setscaling  drms_segment_size  drms_segment_write
drms_segment_write_from_file  drms_template_segments

.De
.SH SYNOPSIS
.nf
#include <drms.h>

typedef struct DRMS_Segment_struct {
  DRMS_Record_t *record;              /* Record segment belongs to */
  DRMS_SegmentInfo_t *info;           /* Series-wide attribute values */
  char filename[DRMS_MAXSEGFILENAME]; /* Storage file name */
  int axis[DRMS_MAXRANK];             /* Size of each dimension */
  int blocksize[DRMS_MAXRANK];        /* Block sizes for TAS storage */
} DRMS_Segment_t;

typedef struct DRMS_SegmentInfo_struct {
  char name[DRMS_MAXNAMELEN];           /* Segment name */
  int segnum;                           /* Segment number in record */
  char description[DRMS_MAXCOMMENTLEN]; /* Description string. */
  int  islink;                          /* Non-0 if segment inherited */
  char linkname[DRMS_MAXNAMELEN];       /* Link to inherit from  */
  char target_seg[DRMS_MAXNAMELEN];	/* Segment to inherit */
  DRMS_Type_t type;                     /* Datatype of data elements */
  int naxis;                            /* Number of dimensions (rank) */
  char unit[DRMS_MAXUNITLEN];           /* Physical unit */
  DRMS_Protocol_t protocol;             /* Storage protocol */
  DRMS_Segment_Scope_t scope;           /* Const, Varies, or DimsVary */
  long long cseg_recnum;                /* Record for constant segment */
} DRMS_SegmentInfo_t;

typedef struct DRMS_SegmentDimInfo_struct {
  int naxis;                            /* Number of dimensions (rank) */
  int axis[DRMS_MAXRANK];               /* Length of each axis */
} DRMS_SegmentDimInfo_t;
				/*  Recognized scope types: */
typedef enum {DRMS_CONSTANT, DRMS_VARIABLE, DRMS_VARDIM} 
    DRMS_Segment_Scope_t;
				/*  Recognized storage protocols: */
typedef enum  {DRMS_GENERIC, DRMS_BINARY, DRMS_BINZIP, DRMS_FITZ,
	DRMS_FITS, DRMS_MSI, DRMS_TAS, DRMS_DSDS, DRMS_LOCAL}
    DRMS_Protocol_t;
				/*  Recognized data types: */
typedef enum {DRMS_TYPE_CHAR, DRMS_TYPE_SHORT, DRMS_TYPE_INT, 
	DRMS_TYPE_LONGLONG, DRMS_TYPE_FLOAT, DRMS_TYPE_DOUBLE, 
	DRMS_TYPE_TIME, DRMS_TYPE_STRING, DRMS_TYPE_RAW}
    DRMS_Type_t;

.fi
.sp
.SH DESCRIPTION
A DRMS data segment corresponds to a named file, typically containing an
n-dimensional scalar array. (It can also be a "generic" segment, which is
just an unstructured file as far as DRMS is concerned.) One or more segments
constitute the external data part(s) of the DRMS record pointed to by the
\fIrecord\fR field. The 
\fIinfo\fR field points to a structure containing attributes common to all
records in a series, while the segment structure itself contains the fields
\fIaxis\fR and \fI blocksize\fR that can vary from record to record if
scope=DRMS_VARDIM.

The \fIprotocol\fR field determines the external storage format used for
storing segment data. Only protocols DRMS_BINARY, DRMS_BINZIP, DRMS_FITS,
DRMS_FITZ, and DRMS_TAS are fully supported. Protocol DRMS_DSDS is a
special protocol for dealing with the format of the Stanford SOI-MDI
Data Sorage and Distribution System (DSDS) and requires support outside
the DRMS library. Protocol DRMS_LOCAL is reserved for other outside
formats;  DRMS_GENERIC and DRMS_MSI are also reserved for unsupported
data formats. In particular, the DRMS_GENERIC protocol is used to refer
to any unstructured data format or data formats of unknown structure.

Data storage for DRMS_FITS is in minimal simple FITS files, without
extensions and with only the compliance- and structure-defining keywords
(SIMPLE, BITPIX, NAXIS, NAXISn, and END, and optionally BLANK, BSCALE and
BZERO) in the headers. All other ancillary data are to be found in the DRMS
record. For the DRMS_FITZ protocol, the representation is similar except
that the entire FITS file is compressed with Rice compression. For the
DRMS_BINARY protocol, the data are written in a binary format, in which
the first 8 bytes are the characters "DRMS RAW", the next \fI8(n+1)\fR
are little-endian integer representations of the data type, rank, and
dimensions of the \fIn\fR axes, and the remainder the binary data in
little-endian format. For the DRMS_BINZIP protocol the represntation is
the same, except that the file iz gzip compressed. The DRMS_TAS protocol
(for "Tiled Array Storage") is described elsewhere, if at all. It is
designed for use with data segments that are small compared with the
size of the full data records, in order to minimize file access without
keeping all of the segment data in the relational database, by concatenating
multiple segments in the external format. The segment blocksize member
is for use with the DRMS_TAS protocol.

Segment data types refer to the scalar data type for the segment, and
should be mostly self-explanatory. DRMS_TYPE_TIME is a special case of
double-precision floating point values representing elapsed time from
a fixed epoch. Arithmetic is the same as for DRMS_TYPE_DOUBLE, only the
format for string representations differs from that for normal floating-point
data; see \fIsprint_time(3)\fR. Data of type DRMS_TYPE_STRING are
null-terminated byte sequences of any length.  Data type DRMS_TYPE_STRING is
not supported by the protocols DRMS_BINARY, DRMS_BINZIP, DRMS_FITS, nor
DRMS_FITZ, Whether it is properly supported by the DRMS_TAS protocol is
doubtful. The data type DRMS_TYPE_RAW is used to describe data that are not
to be converted on read from the type of their external representation,
which must then be established for type-specific operations. It should
be used for DRMS_Array_t structures only, not for Segments.

The scope of a segment can take on three values. The normal scope is
expected to be DRMS_VARIABLE, for which the particular segment for every
record has exactly the same structure (rank, and dimensions),
only the actual data values vary from one record to another. (Note that
different segments of a record, however, need not have the same structure
as one another.) If the scope is DRMS_VARDIMS, then the dimensions and
even rank of the particular segment may vary from one record to another,
although other features of the segment, in particular the data type,
must still be the same. Scope DRMS_CONSTANT is used to describe a data
segment that is constant for all records. It can be used for example to
describe a location index array, or a constant calibration array that
applies to all records in the series, so that it can be made available
to any record without having to store multiple instances externally.

.SH FUNCTIONS
.nf
.I "Read and Write"

\fB
DRMS_Array_t *drms_segment_read (DRMS_Segment_t *seg,
	DRMS_Type_t type, int *status);
DRMS_Array_t *drms_segment_readslice (DRMS_Segment_t *seg,
	DRMS_Type_t type, int *start, int *end, int *status);
int drms_segment_write (DRMS_Segment_t *seg, DRMS_Array_t *arr,
	int autoscale);
int drms_segment_write_from_file (DRMS_Segment_t *seg, char *infile);
.fi
\fR
\fBdrms_segment_read\fR reads the data associated with \fIseg\fR into memory
in a newly created DRMS_Array struct, converting the data to the requested
\fItype\fR (unless \fItype\fR = DRMS_TYPE_RAW, in which case the data type
will be that of the external representation.).

\fBdrms_segment_readslice\fR is similar to \fBdrms_segment_read\fR, except
that only the data between the \fIstart[n]\fR and \fIend[n]\fR values in each
dimension \fIn\fR are read into the array. \fI*start\fR and \fI*end\fR must be
vectors of rank equal to that of the data segment.

\fBdrms_segment_write\fR writes the data from the array \fIarr\fR into the
file associated with the segment \fIseg\fR, provided that the segment uses
one of the supported protocols (DRMS_BINARY, DRMS_BINZIP, DRMS_FITS, DRMS_FITZ,
and DRMS_TAS). The array dimensions must match those of the segment.
If \fIautoscale\fR is non-zero, the function \fBdrms_segment_autoscale\fR
is invoked before output. In any case, conversion to the data type and scaling
appropriate to the segment is performed.

\fBdrms_segment_write_from_file\fR simply copies the contents of the file
specified by \fIinfile\fR into the file associated with \fIseg\fR. It can
only be used for segments whose protocol is DRMS_GENERIC.

.nf
.I "Lookup"

\fB
DRMS_Segment_t *drms_segment_lookup (DRMS_Record_t *record,
	const char *segname);
DRMS_Segment_t *drms_segment_lookupnum (DRMS_Record_t *record,
	int segnum);
#define name2seg(rec, name) drms_segment_lookup (rec, name)
#define num2seg(rec, num) drms_segment_lookupnum (rec, num)
.fi
\fR
\fBdrms_segment_lookup\fR returns the segment associated with the name
\fIsegname\fR in record \fIrec\fR. If the segment refers to a constant
segment that has not yet been set, then the segment for the current
record \fIrec\fR is returned; otherwise, the constant segment is returned.

\fBdrms_segment_lookupnum\fR returns the segment associated with the number
\fIsegnum\fR in record \fIrec\fR. For constant segments, it behaves the same
as \fBdrms_segment_lookup\fR.

.nf
.I "Scaling & blocksize"

\fB
int drms_segment_setscaling (DRMS_Segment_t *seg, double bzero,
	double bscale);
int drms_segment_getscaling (DRMS_Segment_t *seg, double *bzero,
	double *bscale);
void drms_segment_autoscale (DRMS_Segment_t *seg, DRMS_Array_t *array);
void drms_segment_setblocksize (DRMS_Segment_t *seg, int *blksz);
void drms_segment_getblocksize (DRMS_Segment_t *seg, int *blksz);
.fi
\fR
\fBdrms_segment_setscaling\fR sets the values for key (metadata)
values \fBbscale[\fRn\fB]\fR and \fBbzero[\fRn\fB]\fR in the
\fIseg->record\fR struct to \fIbscale\fR and \fIbzero\fR respectively,
where \fIn\fR is the segment number, \fIseg->info->segnum\fR.
These values are used by \fBdrms_segment_read\fR and
\fBdrms_segment_write\fR functions to scale the externally represented
data.

\fBdrms_segment_getscaling\fR returns the scaling parameter keywords,
if they are present in the record struct \fIseg->record\fR as described
above, as \fI*bscale\fR and \fI*bzero\fR. If no valid values are found,
the values 1.0 and 0,0, respectively, are returned. The function returns 1
if no valid value was found for bscale only, 0 otherwise. This is probably
a bug.

\fBdrms_segment_autoscale\fR sets the scaling parameters in the
\fIseg->record\fR keywords, as described above,
to values based on the extrema of the data \fIarray\fR\. The scaling
parameters are set so that the unscaled data would occupy the full range
of the segment fixed-point type; for example the maximum value of the array
would be represented by 127 and the minimum by -128 in the segment data file
if the type were DRMS_TYPE_CHAR. The scaling parameters will only be changed,
however, if the original data would not otherwise fit unscaled into the
range of the segment data type. Setting the scaling parameters for segments
of floating-point type is probably a bad idea, but is done anyway, without
regard to range. For other types, the scaling parameters are simply set to
1 and 0.

\fBdrms_segment_setblocksize\fR sets the \fIseg->blocksize\fR array to the
array of blocksizes \fIblksz\fR.
\fBdrms_segment_getblocksize\fR copies the \fIseg->blocksize\fR array into
the array \fIblksz\fR. \fIblksz\fR must be dimensioned to the rank of the
segment. The blocksize is reserved for use with segments of protocol
DRMS_TAS (tiled array storage) only, but is not used in any of the
read/write functions described here.

.nf
.I "Create & Destroy"

\fB
int drms_template_segments (DRMS_Record_t *template)
HContainer_t *drms_create_segment_prototypes (DRMS_Record_t *target,
	DRMS_Record_t *source, int *status)
HContainer_t *drms_segment_createinfocon (DRMS_Env_t *drmsEnv,
	const char *seriesName, int *status)
int drms_delete_segmentfile (DRMS_Segment_t *seg)
void drms_free_segment_struct (DRMS_Segment_t *segment)
void drms_free_template_segment_struct (DRMS_Segment_t *segment)
void drms_segment_destroyinfocon (HContainer_t **info)
.fi
\fR
\fBdrms_template_segments\fR builds the segment part of a dataset record from
the record \fItemplate\fR by querying the database and using ther results to
initialize the array of segment descriptors.

\fBdrms_create_segment_prototypes\fR creates segment prototypes for the
\fItarget\fR record based on the \fIsource\fR record.

\fBdrms_segment_createinfocon\fR creates a SegmentInfo Hcontainer
appropriate to the records in the data series \fIseriesName\fR based on a
database query.

\fBdrms_delete_segmentfile\fR removes the file storing the \fIseg\fR data..

\fBdrms_free_segment_struct\fR is actually a no-op, unless the
\fIsegment\fR pointer is NULL, in which case an error is generated.

\fBdrms_free_template_segment_struct\fR frees the SegmentInfo member of the
segment \fIsegment->info\fR.

\fBdrms_segment_destroyinfocon\fR destroys the SegmentInfo Hcontainer
\fR*info\fI.

.nf
.I "Replicate"

\fB
void drms_copy_segment_struct (DRMS_Segment_t *dst, DRMS_Segment_t *src)
.fi
\fR
copies the entire \fIsrc\fR Segment struct to \fIdst\fR.

.nf
.I "Manipulate Axes"

\fB
int drms_segment_setdims (DRMS_Segment_t *seg,
	DRMS_SegmentDimInfo_t *di)
int drms_segment_getdims (DRMS_Segment_t *seg,
	DRMS_SegmentDimInfo_t *di)
.fi
\fR
\fBdrms_segment_setdims\fR sets the rank and axis lengths of \fIseg\fR to
those of the \fIdi\fR struct.

\fBdrms_segment_getdims\fR  sets the values of the \fIdi\fR struct to the
rank and axis lengths of \fIseg\fR.

.nf
.I "Information & Diagnostics"

\fB
void drms_segment_print (DRMS_Segment_t *seg)
void drms_segment_filename (DRMS_Segment_t *seg, char *filename)
long long drms_segment_size (DRMS_Segment_t *seg, int *status)
int drms_segment_segsmatch (const DRMS_Segment_t *s1,
	const DRMS_Segment_t *s2)
.fi
\fR
\fBdrms_segment_print\fR prints the full \fIseg\fR struct information to
\fIstdout\fR

\fBdrms_segment_filename\fR returns the absolute path to the segment file
for \fIseg\fR in \fIfilename\fR. The string \fIfilename\fR must be at least
DRMS_MAXPATHLEN+1 bytes long.

\fBdrms_segment_size\fR total size of the \fIseg\fR data array, in bytes
(product of the dimensions and size of the datatype). If the segment data
type is DRMS_TYPE_STRING, the size returned is only the number of data
times the size of an address.

\fBdrms_segment_segsmatch\fR returns 1 if both segments exist (or are NULL)
and have the same rank, dimensions, protocol, blocksizes (if they are of
protocol DRMS_TAS), type, and scope; 0 otherwise.
\fR
.SH "SEE ALSO"
.BR drms_record (3),
.BR drms_keyword (3),
.BR drms_link (3),
.BR drms_array (3)
