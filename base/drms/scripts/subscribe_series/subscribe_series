#!/bin/bash
#export SSH_AUTH_SOCK=/tmp/ssh-HgUgDH2809/agent.2809
#export SSH_AGENT_PID=2810

function RM {

  cmd="/bin/rm";
  args="$@"

  $cmd $@
  if [ $? -ne 0 ]
  then
    logecho "error running command [$cmd $args]"
    exit 1;
  else
    logwrite "successful rm command [$cmd $args]"
  fi
}

## shell wrappers declaration - From Igor (slight mod by Art)
function MV {

  cmd="/bin/mv";
  args="$@"

  $cmd $@
  if [ $? -ne 0 ]
  then
    logecho "error running command [$cmd $args]"
    exit 1;
  else
    logwrite "successful mv command [$cmd $args]"
  fi
}

function SCP {

  cmd="scp";
  args="$@"

  $cmd $@
  if [ $? -ne 0 ]
  then
    logecho "error running command [$cmd $args]"
    exit 1;
  else
    logwrite "successful scp command [$cmd $args]"
  fi
}

function SSH {

  cmd="ssh";
  args="$@"

  $cmd $@
  if [ $? -ne 0 ]
  then
    logecho "error running command [$cmd $args]"
    exit 1;
  else
    logwrite "successful ssh command [$cmd $args]"
  fi
}

## logs to log file and stdout!                                                               
function logecho {
  if [ ! -z "$logfile" ]
  then
    echo $1 | tee -a $logfile;
  fi
}

function TableExists () {
    exists=0
    ns=$1
    relname=$2
    seq=$3

    if [ $seq -ne 0 ]
    then
        cmd="\ds"
    else
        cmd="\dt"
    fi

    psql -p "$pg_port" -h "$pg_host" -U "$pg_user" -t -c "$cmd $ns.$relname" "$pg_dbname" > sqlcheck.tmp 2>&1

    result=`egrep 'No matching' sqlcheck.tmp`

    if [ -z "$result" ]
    then
        exists=1
    fi

    return $exists
}

#--------------------------------------------------------------------
# syntax check
#--------------------------------------------------------------------
if [ $# -eq 3 ]
then
	config_file="$1"
	subscribe_file="$2"
	rsFile="$3"
else
	error="ERROR: Usage: $0 <configuration file> <subscribe request file> <ssh-agent_rs file>"
	echo $error
	exit
fi

# extract seriesname from the $subscribe_file file
series=`awk '{print $1}' "$subscribe_file" | egrep '^[^#[:space:]]'`

. "$config_file"

#--------------------------------------------------------------------
# Setting up the log
#--------------------------------------------------------------------
## checks if a preferred LOCAL_LOG_DIR has been specified in the $config_file                 
if [ -z "$kLocalLogDir" ]
then
  logfile=../log/$0.log
else
  logfile="$kLocalLogDir/$0.log"
fi

if [ -z "$kMaxLog" ]
then
  maxlog=1048576
else
  maxlog="$kMaxLog"
fi

if [ ! -f "$logfile" ]
then
  touch "$logfile"
  if [ $? -ne 0 ]
  then
    logecho "Couldn't touch log file [$logfile] ... exiting."
    exit 1;
  fi
else
  # log exists, truncate if getting too big
  sz=`stat -c%s $logfile`
  if [ $sz -ge $maxlog ]
  then
    : > "$logfile"
    if [ $? -ne 0 ]
      then
        logecho "Couldn't truncate log file [$logfile] ... exiting."
      exit 1;
    fi
  fi
fi

# If there is a second argument to logwrite, regardless of 
# what that argument is, an empty date line will be written
logwrite () {
        echo `date +"%m-%d-%Y %H:%M:%S - "` "$1" >> "$logfile"
        if [ ! $2 == "" ]
        then
        	echo `date +"%m-%d-%Y %H:%M:%S - "` >> "$logfile"
        fi
}

logwrite "Starting $0 from $scriptdir" nl

#--------------------------------------------------------------------
# Set up ssh keys
#--------------------------------------------------------------------
echo > set.sh
exec < "$rsFile"
while read line; do
        set - $line
        if [ "$1" == "setenv" ]; then
                tag="$2"
                shift
                shift
                echo "export ${tag}=$*  " >> set.sh
                export ${tag}="$*"
        fi
done

. set.sh

RM -f set.sh

#--------------------------------------------------------------------
# Prepare trigger file
#--------------------------------------------------------------------
echo > temp.tgr
logwrite "Created temp.tgr"
echo "archive $archive" >> temp.tgr
echo "retention $retention" >> temp.tgr
echo "tapegroup $tapegroup" >> temp.tgr
echo "node $node" >> temp.tgr

cat "$subscribe_file" | grep -v "\#" >> temp.tgr

#--------------------------------------------------------------------
# Check to see if the schema and database exists on the subscribers database
#--------------------------------------------------------------------
logwrite "Executing [psql -p $pg_port -U $pg_user $pg_dbname -c '\dt admin.*' | grep \" ns \"]"
check=`psql -p "$pg_port" -U "$pg_user" "$pg_dbname" -c '\dt admin.*' | grep " ns "`

if [ ! "$check" == "" ]
then
	logwrite "admin schema and table ns exist" 
else
	logwrite "ERROR: admin schema and table ns do NOT exist" 
	logwrite "ABORTING"
	logwrite "Removing temp.tgr"
	RM -f temp.tgr
	logwrite "Exiting $0"
	exit 1
fi

#--------------------------------------------------------------------
# Stopping ingestion script and copy trigger file to Manager
#--------------------------------------------------------------------
logwrite "Stopping the ingestion script (creating die file)"
logwrite "Creating get_slony_logs.$node.die in $ingestion_path" nl
echo > "$ingestion_path/get_slony_logs.$node.die"
triggerfile="$node".subscribe_series.tgr
logwrite "Renaming temp.tgr to $triggerfile" nl
MV -f temp.tgr "$triggerfile"


logwrite "Copying $triggerfile to $webdb_user@$webdb_ip:$webdb_dir" nl

# XXX - ART
# What we want to do is to use file locking so that the server
# doesn't try to read the trigger file until the client is done with
# it. The client (this script) should lock the file, then 
# scp it, then chgrp/chmod it (this script should do the
# chgrp/chmod).
chmod g+w "$triggerfile"
SCP -p "$triggerfile" "$webdb_user@$webdb_ip:$webdb_dir/."

logwrite "Removing $triggerfile" nl

RM -f "$triggerfile"


#--------------------------------------------------------------------
# Loop waiting for sqldone file to continue (meaning sql is ready to be applied)
#--------------------------------------------------------------------
logecho -n "Waiting to retrieve the sql file from the subscription manager"
counter=0
while [ 1 -eq 1 ]
do	
	if [ $counter -ge $attempts ] 
	then
		logecho "ERROR: Did not find $node.subscribe_series.sqldone after 20 tries"
		logecho "ERROR: Couldn't find the sql file required to continue!"
		logecho "ABORTING - exiting $0"
		exit
	fi		


        result=`SSH "$webdb_user@$webdb_ip" 'ls '"'$webdb_dir'"`;

        ## error on SSH; couldn't find $webdb_dir                                                 
        error=`echo $result | grep -i error`;
        if [ ! -z "$error" ]
            then
            logecho "Couldn't find $webdb_dir directory ... exiting";
            exit 1;
        fi

        check=`echo $result | grep "$node.subscribe_series.sqldone"`;
	
	if [ ! -z "$check" ]
	then
		logwrite "Found $node.subscribe_series.sqldone, continuing"
		logecho
		logecho "Subscription manager finished creating the sql file, retrieving it."
		break
	else
		counter=$(( $counter + 1 ))
		logwrite "Did not find $node.subscribe_series.sqldone, sleeping for five seconds"
		logecho -n "."
		sleep 5
	fi

done

unset check
unset error
unset result

# Checking trigger file for failure code
result=`SSH $webdb_user@$webdb_ip 'cat '"'$webdb_dir/$node.subscribe_series.sqldone'"`;

## Check for error in remote ssh command; trigger file not found or failed SSH
error=`echo $result | grep -i error`;
if [ ! -z $error ] ;
then
  logecho "Fail cat $webdb_dir/$node.subscribe_series.sqldone"
  exit 1;
fi

check=`echo $result | grep failure`;

if [ ! "$check" == "" ]
then
	logecho "ERROR: One or more of the schemas did not exist on the webdb"
	logecho "ERROR: ABORTING!" nl
	logwrite "Removing sqldone trigger file from webdb"
        SSH "$webdb_user@$webdb_ip" 'rm -f '"'$webdb_dir/$node.subscribe_series.sqldone'"
	logwrite "Restarting the ingestion script"
	logwrite "Removing ingestion.die in $ingestion_path" nl
	RM -f "$ingestion_path/get_slony_logs.$node.die"
	exit 1;
fi

unset check
unset error
unset result

# sqldone file found, transferring sql file to local machine
logwrite "Copying and removing $node.sql.tar.gz file from $webdb_user@$webdb_ip"
SCP "$webdb_user@$webdb_ip:$webdb_dir/$node.sql.tar.gz" .
SSH "$webdb_user@$webdb_ip" 'rm -f '"'$webdb_dir/$node.sql.tar.gz'"

logwrite "Executing: tar -xzvf $node.sql.tar.gz"
tar -xzvf "$node.sql.tar.gz"

logwrite "Removing $node.sql.tar.gz" nl
RM -f "$node.sql.tar.gz"

#--------------------------------------------------------------------
# Execute the SQL files, return a value 
#--------------------------------------------------------------------
# Execute $node.createns.sql
logecho "Applying SQL file $node.createns.sql to database"

# Add check for slony cluster schema (eg, _jsoc), and don't proceed if it exists
# If entry in admin.ns exists, do not apply createns.sql. However, 
# we cannot assume that the drms_* tables and sequence exist. If any of these
# tables is missing, bail.
#   name - schema of series being subscribed to
#   owner - PG user that owns this series (should be slony)

adminnsexist=0
schemaexist=0

nsname=`echo ${series%%.*}`

logwrite "seriesname is $series"
logwrite "series namespace is $nsname"

# Check for schema existence
logwrite "Executing [psql -p $pg_port -h $pg_host -U $pg_user -t -c SELECT * FROM pg_catalog.pg_namespace WHERE nspname = '$nsname' $pg_dbname]"
psql -p "$pg_port" -h "$pg_host" -U "$pg_user" -t -c "SELECT * FROM pg_catalog.pg_namespace WHERE nspname = '$nsname'" "$pg_dbname" > sqlcheck.tmp 2>&1
result=`egrep '.' sqlcheck.tmp`
if [ ! -z "$result" ]
then
    schemaexist=1
fi

# Check for admin.ns entry existence
logwrite "Executing [psql -p $pg_port -h $pg_host -U $pg_user -t -c SELECT * FROM admin.ns WHERE name = '$nsname' AND owner = '$pg_user' $pg_dbname]"
psql -p "$pg_port" -h "$pg_host" -U "$pg_user" -t -c "SELECT * FROM admin.ns WHERE name = '$nsname' AND owner = '$pg_user'" "$pg_dbname" > sqlcheck.tmp 2>&1
result=`egrep '.' sqlcheck.tmp`
if [ ! -z "$result" ]
then
    adminnsexist=1
fi

logwrite "table schema check: $schemaexist; schema adminns entry check: $adminnsexist"

# If one or the other exists, then we can't apply createns.sql AND the schema, admin.ns entry, drms_* tables must exist
check=good
docreatens=1
if [ $schemaexist -ne 0 -o $adminnsexist -ne 0 ]
then
    docreatens=0
    if [ $schemaexist -eq 0 -o $adminnsexist -eq 0 ]
    then
        check=failed
        logecho "Missing schema or entry in the admin.ns table; failing."
    else
        # Search for tables
        TableExists $nsname "drms_series" 0
        result=$?

        if [ ! $result ]
        then
            check=failed
        fi

        if [ ! $check == "failed" ]
        then
            TableExists $nsname "drms_keyword" 0
            result=$?
        fi
        
        if [ ! $result ]
        then
            check=failed
        fi

        if [ ! $check == "failed" ]
        then
            TableExists $nsname "drms_link" 0
            result=$?
        fi
        
        if [ ! $result ]
        then
            check=failed
        fi

        if [ ! $check == "failed" ]
        then
            TableExists $nsname "drms_segment" 0
            result=$?
        fi
        
        if [ ! $result ]
        then
            check=failed
        fi

        if [ ! $check == "failed" ]
        then
            TableExists $nsname "drms_session" 0
            result=$?
        fi
        
        if [ ! $result ]
        then
            check=failed
        fi

        if [ ! $check == "failed" ]
        then
            TableExists $nsname "drms_sessionid_seq" 1
            result=$?
        fi
        
        if [ ! $result ]
        then
            check=failed
        fi

         if [ $check == "failed" ]
         then
             logecho "Incomplete set of schema drms_* tables; failing."
         fi
    fi
fi

if [ ! $check == "failed" ]
then
    if [ $docreatens -ne 0 ]
    then
        logwrite "Executing [psql -p $pg_port -h $pg_host -U $pg_user -ef $node.createns.sql $pg_dbname]"
        psql -p "$pg_port" -h "$pg_host" -U "$pg_user" -ef "$node.createns.sql" "$pg_dbname" > sqlcheck.tmp 2>&1
        result=`cat sqlcheck.tmp`
        logwrite $result
    else
        logwrite "Check for existing schema $nsname succeeded - no need to apply createns.sql"
    fi

    logecho "Applying SQL file $node.subscribe_series.sql to database"
    logwrite "Executing [psql -p $pg_port -h $pg_host -U $pg_user -ef $node.subscribe_series.sql $pg_dbname]"
    psql -p "$pg_port" -h "$pg_host" -U "$pg_user" -ef "$node.subscribe_series.sql" "$pg_dbname" > sqlcheck.tmp 2>&1
    result=`cat sqlcheck.tmp`
    logwrite $result

    check=`cat sqlcheck.tmp | grep "ERROR:"`
    logwrite "Checking for errors with $node.subscribe_series.sql"
    logwrite "Found errors: [$check]" nl

    if [  ! "$check" == "" ] 
    then
	logwrite "Failed to apply $node.subscribe_series.sql"
	logwrite "Rolling back to previous state"
	success=false
    else
	logwrite "Application of $node.subscribe_series.sql succeded, continuing"
	success=true
    fi
else
    success=false;
fi

RM -f sqlcheck.tmp

if [ $success == "true" ]
then
	# SQL applictaion was a success, appending [success true] to the cfg file on webdb
	logwrite "SQL application successful, appending [success=true] to the cfg file on webdb"
	SSH "$webdb_user@$webdb_ip" 'echo '"success true"' >> '"'$webdb_dir/$node.subscribe_series.cfg'"
else
	# SQL application was unsuccessful, appending [success false] to the cfg file on webdb
	logwrite "SQL application unsuccessful, appending [success=false] to the cfg file on webdb"
        logecho "Failure to apply SQL file '$node.subscribe_series.sql' from server: ABORTING!"
	SSH "$webdb_user@$webdb_ip" 'echo '"success false"' >> '"'$webdb_dir/$node.subscribe_series.cfg'"
fi

SSH "$webdb_user@$webdb_ip" 'cp -f '"'$webdb_dir/$node.subscribe_series.cfg'"' '"'$webdb_dir/$node.subscribe_series.sqlapplied'"

unset result
unset check

#--------------------------------------------------------------------
# Loop waiting for done file to continue (which signifies that manager is done and has cleaned up)
#--------------------------------------------------------------------
logecho -n "Waiting for the subscription manager to finish updating the subscription parser, complete, and clean-up"
counter=0
while [ 1 -eq 1 ]
do	
	if [ "$counter" -ge "$attempts" ] 
	then
		logwrite "ERROR: Did not find $node.subscribe_series.done after $attempts tries"
		logwrite "ERROR: Exiting $0 " nl
		logecho "ERROR: The subscription manager has not reported it has finished updating the subscription parser after $attempts tries!"
		logecho "ABORTING!"
		exit 1;
	fi		


        result=`SSH "$webdb_user@$webdb_ip" 'ls '"'$webdb_dir'"`;

        logwrite "result is $result"

        ## Check for error in remote ssh command; Couldn't find $webdb_dir directory
        error=`echo $result | grep -i error`;
        if [ ! -z $error ] ;
        then
            logecho "Couldn't find $webdb_dir directory or broken SSH ... exiting"
            exit 1;
        fi

	check=`echo $result | grep "$node.subscribe_series.done"`
		
	if [ ! "$check" == "" ]
	then
		logwrite "Found $node.subscribe_series.done, continuing"
		logecho
		logecho "Subscription manager has finished updating the parser and cleaned-up."
		break
	else
		counter=$(( $counter + 1 ))
		logwrite "Did not find $node.subscribe_series.done, sleeping for five seconds"
		logecho -n "."
		sleep 5
	fi

done

unset check
unset error
unset result

#--------------------------------------------------------------------
# Starting the ingestion script (by removing the die file)
#--------------------------------------------------------------------
logwrite "Starting the ingestion script"
logwrite "Removing ingestion.die in $ingestion_path" nl
RM -f "$ingestion_path/get_slony_logs.$node.die"

logwrite "Cleaning up the done file '$webdb_dir/$node.subscribe_series.done' (which the server cleanup file wrote)" nl
SSH "$webdb_user@$webdb_ip" 'rm -f '"'$webdb_dir/$node.subscribe_series.done'"

#--------------------------------------------------------------------
# Removing the ingested sql files
#--------------------------------------------------------------------
logwrite "Removing the $node.createns.sql file"
RM -f "$node.createns.sql"

logwrite "Removing the $node.subscribe_series.sql file"
RM -f "$node.subscribe_series.sql"

#--------------------------------------------------------------------
# Finish
#--------------------------------------------------------------------
logwrite "$0 complete"
logecho

if [ $success  == "true" ]
then
	logecho "Subscription process completed successfully!"
else
	logecho "Subscription process did not complete successfully!"
fi
