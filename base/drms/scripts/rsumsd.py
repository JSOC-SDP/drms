#!/usr/bin/env python

from __future__ import print_function
import sys
import re
import os
import stat
import filecmp
import thread
import psycopg2
import threading
import fcntl
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../../include'))
from drmsparams import DRMSParams
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../../base/libs/py'))
from drmsCmdl import CmdlParser
from drmsLock import DrmsLock

from subprocess import check_output, CalledProcessError, Popen

# This script runs as a daemon at the site that has requested an SU that does not belong to the site. It is responsible for contacting
# the owning site and requesting the path to the desired SUs. The owning site must be running the rs.py CGI to respond to the requesting
# site's request.

# There are three database tables: 1., a DRMS site table, 2., a request table, and 3., an SU table. The site table (sitename, sitecode, baseurl) provides
# the information needed to query the providing site for the information needed to scp the requested SUs to the requesting site. The URL to the cgi
# program that provides scp information is formed by appending "rs.py" to baseurl. There are two parameters for this cgi: 1., "requestid", and 2., "sunums".
# During the initial request to the providing site, the requesting site will provide a requestid of "none", and a comma-separated list of SUNUMs
# in the sunums argument. Should the providing site have all the requested SUs online, then it will return the scp information needed to access those
# SUs, and a status of "complete". If, however, the SUs are not all online, the initial request will start an asynchronous tape-read of the offline SUs,
# returning a request ID that identifies the initial request, and a status of "pending". The requesting site must then poll for completion by
# periodically calling the cgi with a status request. To make a status request, the requestid argument contains the requestid returned by the
# inital CGI call, and the sunums argument contains "none". While the data are not ready, the status request returns a status of "pending". When
# the data are online, the status request returns a status of "complete".
#
# The request table (requestid, sunums, status) is populated by drms_storageunit.c. For all SUs that are offline and are not owned by the running
# DRMS/SUMS, the code inserts a record into the request table. The requestid is a UUID (within the running DRMS/SUMS) generated by a sequence table.
# The list of SUNUMs is put in sunums, and the initial status is set to 'N' (New request). drms_storageunit.c chunks such SUNUMs into
# manageable-sized requests. After inserting one or more such records into the request table, drms_storageunit.c then polls these records,
# waiting for the status to become 'C' (Complete request). After that happens, drms_storageunit.c then calls SUM_get() again on these SUs
# to obtain their paths. This daemon, rsumsd.py, periodically and reads all records in the request table. For each SU in each 'N' record
# (a single request, which could be requesting multiple SUs) the daemon first checks if the SU is already being processed. If so, then
# the SU table is not modified. The status of the record in the request table is set to 'P'. If the SU is not in the SU table, then
# this can mean one of two things. The daemon has never processed this SU, or the daemon has already processed this SU. When the daemon has completed
# processing an SU, it deletes the record for the SU from the SU table. If the latter is true, the daemon should not re-process the same SU. To distinguish
# between these two possibilities, the daemon first checks to see if the SU is already present in SUMS (it calls show_info -o sunum=SUNUM).
# If the SU is online, then the daemon does nothing. But if it is offline, then the daemon inserts a record for the SU into the SU table, and starts
# processing that SU. The status of that SU-table record is set to 'P', as is the status of the request record containing that SUNUM.
#
# For each SU in each 'P' request record, the daemon searches for records in the SU table. If one or more such records exist in the SU table, then
# the request record is left in the pending state. The next time the daemon scans the request records, it will again check the SU table looking
# for completion of all SUs. When that occurs, the status of the request record is set to 'C', indicating that the request is complete. The
# drms_storageunit.c code will then call SUMS to get the newly created paths to the requested SUs.

RET_SUCCESS = 0
RET_INVALIDARGS = 1
RET_LOCK = 2

class SuTable:
    def __init__(self, cursor, tableName):
        self.cursor = cursor
        self.tableName = tableName
        self.suDict = {}
        
    def setCursor(self, cursor):
        self.cursor = cursor

    def read(self):
        # sus(sunum, refcount, status, message)
        cmd = 'SELECT sunum, refcount, status FROM ' + self.tableName
    
        try:
            self.cursor.execute(cmd)
    
        except psycopg2.Error as exc:
            raise Exception('sql', exc.diag.message_primary, cmd)
    
        for record in cursor:
            self.suDict[record[0]] = {}
            self.suDict[record[0]]['refcount'] = record[1]
            self.suDict[record[0]]['status'] = record[2]

    def write(self, sus):
        # sus(sunum, refcount, status, message)
        try:
            cursor.execute('PREPARE preparedStatement AS INSERT INTO ' + suTable + ' VALUES($1, $2, $3, $4)')
            for key in sorted(sus.iterkeys()):
                cursor.execute('EXECUTE preparedstatement (%s, %s, %s)', (key, sus[key]['refcount'], sus[key]['status']), sus[key]['msg'])
    
        except psycopg2.Error as exc:
            raise Exception('sql', exc.diag.message_primary, cmd)

    def setStatus(self, sunum, code, msg):
        self.suDict[sunum]['status'] = code
        if msg is not None:
            self.suDict[sunum]['status'] = msg
        else:
            self.suDict[sunum]['status'] = ''


# Downloads a single SU. Ingests it into SUMs (SUMS allows to ingestion of a single SU at a time only.). Updates
# the SU table status for that SU.
class Downloader(threading.Thread):
    tSeq = 0
    tList = [] # A list of running thread IDs.
    compSunum = -1 # The SUNUM of the SU just processed.
    maxThreads = 16 # A constant.
    eventMaxThreads = threading.Event() # Event fired when the number of threads decreases.
    eventSunum = threading.Event() # Event fired when compSunum gets set to -1.
    lock = threading.Lock() # Guard tList, compSunum, and tSeq guard.

    def __init__(self, sunum, path, suTable, scpPort, scpUser, scpHost, binPath):
        threading.Thread.__init__(self)
        Downloader.lock.acquire()
        self.threadnum = Downloader.tSeq # Thread ID.
        Downloader.tSeq += 1
        Downloader.lock.release()
        self.sunum = sunum
        self.path = path
        self.suTable = suTable
        self.scpPort = scpPort
        self.scpUser = scpUser
        self.scpHost = scpHost
        self.binPath = binPath

    def run(self):
        # Download the SU.
        
        # Don't forget to make the temporary directory first.
        cmdList = ['scp', '-r', '-P', self.scpPort, self.scpUser + '@' + self.scpHost + ':' + self.path + '/*', '/tmp/.su' + str(self.sunum)]
        try:
            check_call(cmdList)
        except CalledProcessError as exc:
            raise Exception('scp', "Command '" + ' '.join(cmdList) + "' returned non-zero status code " + str(exc.returncode))

        # Ingest the SUs into SUMS. size matters not...look at me...judge me by my size, do you?
        cmdList = [binPath + '/vso_sum_alloc', 'sunum=' + str(self.sunum), 'size=1024']
        try:
            resp = check_output(cmdList)
            output = resp.decode('utf-8')
        except CalledProcessError as exc:
            raise Exception('vso_sum_alloc', "Command '" + ' '.join(cmdList) + "' returned non-zero status code " + str(exc.returncode) + '.')
        
        regExp = re.compile(r'.+sudir:(\S+)')
        matchObj = regExp.match(output)
        if matchObj is not None:
            sudir = matchObj.group(1)
        else:
            raise Exception('vso_sum_alloc', "Command '" + ' '.join(cmdList) + "' printed unexcepted output " + output + '.')
        
        cmdList = ['mv', '/tmp/.su' + str(self.sunum) + '/*', sudir]
        try:
            check_call(cmdList)
        except CalledProcessError as exc:
            raise Exception('mv', "Command '" + ' '.join(cmdList) + "' returned non-zero status code " + str(exc.returncode))
        
        # Remove temporary directory.
        
        # Update SU table. Set SU-table record status to 'C'.
        suTable.setStatus(self.sunum, 'C', None)
        
        # This thread is about to terminate.
        
        # Each thread must block if compSunum != -1. compSunum == 1 ==> an SU just got downloaded, and
        # we need to pass the SUNUM of the SU just downloaded to the main thread before any other
        # thread can be allowed to terminate. We also need to check the class tList variable to update it.
        # For both reasons, we must acquire the lock.
        Downloader.lock.acquire()
        
        while Downloader.compSunum != -1:
            Downloader.lock.release()
            Downloader.eventSunum.wait()
            Downloader.lock.acquire()
        
        Downloader.tList.remove(self) # This thread is no longer one of the running threads.
        if len(Downloader.tList) == Downloader.maxThreads - 1:
            # Fire event so that main thread can add new SUs to the download queue.
            Downloader.eventMaxThreads.set()
            # Clear even so that main will block the next time it calls wait.
            Downloader.eventMaxThreads.clear()

        Downloader.compSunum = self.sunum

        
        Downloader.lock.release()

def getCfg(path):
    pass

def getOption(val, default):
    if val:
        return val
    else:
        return default

def getArgs(args):
    istat = False
    optD = {}
    
    parser = CmdlParser(usage='%(prog)s [ -h ] sutable=<storage unit table> reqtable=<request table> [ --dbname=<db name> ] [ --dbhost=<db host> ] [ --dbport=<db port> ]')
    
    # Optional parameters - no default argument is provided, so the default is None, which will trigger the use of what exists in the configuration file
    # (which is drmsparams.py).
    parser.add_argument('n', 'sitetable', '--sitetable', help='The database table that contains records of the storage units being processed. If provided, overrides default specified in configuration file.', metavar='<site table>', dest='sitetable')
    parser.add_argument('r', 'reqtable', '--reqtable', help='The database table that contains records of the SU-request being processed. If provided, overrides default specified in configuration file.', metavar='<request unit table>', dest='reqtable')
    parser.add_argument('s', 'sutable', '--sutable', help='The database table that contains records of the storage units being processed. If provided, overrides default specified in configuration file.', metavar='<storage unit table>', dest='sutable')
    parser.add_argument('-N', '--dbname', help='The name of the database that contains the series table from which records are to be deleted.', metavar='<db name>', dest='dbname')
    parser.add_argument('-H', '--dbhost', help='The host machine of the database that contains the series table from which records are to be deleted.', metavar='<db host machine>', dest='dbhost')
    parser.add_argument('-P', '--dbport', help='The port on the host machine that is accepting connections for the database that contains the series table from which records are to be deleted.', metavar='<db host port>', dest='dbport')
  
    try:
        args = parser.parse_args()
          
    except Exception as exc:
        if len(exc.args) == 2:
            type = exc[0]
            msg = exc[1]
                  
            if type != 'CmdlParser-ArgUnrecognized' and type != 'CmdlParser-ArgBadformat':
                raise # Re-raise
                  
            print(msg, file=sys.stderr)
            istat = True
            optD = None
              
        else:
            raise # Re-raise
  
    if not istat:
        try:
            drmsParams = DRMSParams()
            if drmsParams is None:
                raise Exception('drmsParams', 'Unable to locate DRMS parameters file (drmsparams.py).')
            
            # Get configuration information.
            optD['cfg'] = drmsParams
            
            # Override defaults.
            optD['sitetable'] = getOption(args.sitetable, drmsParams.get('RS_SITE_TABLE'))
            optD['reqtable'] = getOption(args.reqtable, drmsParams.get('RS_REQUEST_TABLE'))
            optD['sutable'] = getOption(args.sutable, drmsParams.get('RS_SU_TABLE'))
            optD['dbname'] = getOption(args.dbname, drmsParams.get('RS_DBNAME'))
            optD['dbhost'] = getOption(args.dbhost, drmsParams.get('RS_DBHOST'))
            optD['dbport'] = getOption(args.dbport, drmsParams.get('RS_DBPORT'))
            optD['lockfile'] = getOption(None, drmsParams.get('RS_LOCKFILE'))
    
        except Exception as exc:
            if len(exc.args) != 2:
                raise # Re-raise
        
            etype = exc.args[0]
            msg = exc.args[1]
        
            if etype == 'drmsParams':
                print('Error reading DRMS parameters: ' + msg, file=sys.stderr)
                istat = True
                optD = None
    
        except KeyError as exc:
            type, value, traceback = sys.exc_info()
            print(exc.strerror, file=sys.stderr)
            istat = True
            optD = None
    
    return optD

def filterSunums(sunumList, sus, jfPath):
    rv = []
    
    # Pass SUNUM only if it is offline and not being current processed.
    notBeingProcessed = [ sunum for sunum in sunumList if not sunum in sus ]
    if len(notBeingProcessed) > 0:
        # There is not an efficient way to check for the SU being on/offline. But we can use jsoc_info (vs. show_info - jsoc_info returns
        # JSON, which is handy). And it also can be called in a mode where it does not trigger a SUM_get() - it uses SUM_infoEx():
        #   op=exp_su requestid=NOASYNCREQUEST sunum=123456789 format=json formatvar=dataobj method=url_quick protocol=as-is
        cmd = jfPath + ' op=exp_su requestid=NOASYNCREQUEST format=json formatvar=dataobj method=url_quick protocol=as-is sunum=' + ','.join(notBeingProcessed)
    
        try:
            resp = check_output(cmd)
            output = resp.decode('utf-8')
    
        except ValueError:
            raise Exception('jfetch', "Unable to run command: '" + ' '.join(cmd) + "'.")
        except CalledProcessError as exc:
            raise Exception('jfetch', "Command '" + ' '.join(cmd) + "' returned non-zero status code " + str(exc.returncode))

        offline = []
        jsonObj = json.loads(output)
        for sunum in jsonObj['data']:
            if jsonObj['data'][sunum]['sustatus'] == 'N':
                offline.append(sunum)
                    
        rv = offline
    else:
        rv = notBeingProcessed

    return rv

def newDownload(cursor, url, sunumList):
    pass

# Process the SUs for the source site represented by url.
# url - the URL (base URL plus cgi arguments, except for the sunum= argument) from which SU paths can be obtained.
# sunums - a list of sorted SUNUMs to download.
def processSU(dbconn, url, sunums):
    # Create the sunum= argument.

    # Break-up large requests from a single URL into multiple smaller requests.
    nElems = len(sunums[url])
    iLastChunk = nElems / MAX_SUS

    iChunk = 0
    while iChunk <= iLastChunk:
        if iLastChunk == iChunk:
            end = nElems
        else:
            end = (ichunk + 1) * MAX_SUS - 1

        sunumChunk = sunums[iChunk * MAX_SUS : end]

        iChunk += 1


rv = RET_SUCCESS

if __name__ == "__main__":
    optD = getArgs(sys.argv[1:])
    if not optD:
        rv = RET_INVALIDARGS

    if rv == RET_SUCCESS:
        try:
            pid = os.getpid()
            
            with DrmsLock(optD['lockfile'], str(pid)) as lock:
                sys.exit(1)

                # Connect to the database
                try:
                    # The connection is NOT in autocommit mode. If changes need to be saved, then conn.commit() must be called.
                    with psycopg2.connect(database=optD['dbname'], user=optD['dbuser'], host=optD['dbhost'], port=optD['dbport']) as conn:
                        with conn.cursor() as cursor:
                            reqTable = optD['reqtable']

                            sites = None
                            requests = None
                            sus = None
                    
                            cmd = 'SELECT requestid, sunums, status FROM ' + reqTable
                            try:
                                cursor.execute(cmd)
            
                            except psycopg2.Error as exc:
                                raise Exception('sql', exc.diag.message_primary, cmd)
            
                            requests = cursor.fetchall()
                    
                            # Iterate through returned records. Need to split the requests into two lists: a list of new requests, and a list of
                            # pending requests.
                            newRequests = []
                            pendingRequests = []
                            
                            for arequest in requests:
                                if arequest[3] == 'N':
                                    newRequests.append[arequest]
                                else:
                                    pendingRequests.append[arequest]
                    
                            siteUrls = {}
                            siteSunums = {} # New sunum CGI requests to providers.
                    
                            # Process new requests
                            if len(newRequests) > 0:
                                # We will need to map SUNUMs to site base URLs, so load up the sites table.
                                cmd = 'SELECT sitecode, baseurl FROM ' + siteTable
                                try:
                                    cursor.execute(cmd)

                                except psycopg2.Error as exc:
                                    raise Exception('sql', exc.diag.message_primary, cmd)
                                
                                sites = cursor.fetchall()
                                
                                for asite in sites:
                                    code = asite[0]
                                    siteUrls[code] = asite[1]
                             
                                for arequest in newRequests:
                                    reqID = record[0]
                                    sunumsStr = record[1]
                                    reqStatus = record[2]
                            
                                    sunumList = sunumsStr.split(',')
                                
                                    chunker = Chunker(sunumList)
                                    
                                    try:
                                        # Request from providers, but only if the SUNUM has not already been processed and is not currently being processed.
                                        for chunk in chunker:
                                            sunumList = chunk.getItems()

                                            # Filter out SUs that are being processed, or already online.
                                            sunumListOffline = filterSunums(sunumList)
                                    
                                            # Organize SUNUMs by owning site.
                                            for asunum in sunumListOffline:
                                                code = getSiteCode(asunum)
                                                if code is not None:
                                                    url = siteUrls[code]
                                                    if url not in siteSunums:
                                                        siteSunums[url] = []
                                        
                                                    siteSunums[url].append(asunum)
                                                else:
                                                    # Could not obtain site code - error.
                                                    raise Exception('sitecode', 'Error request ID ' + reqID + '. Unable to get site code for SUNUM ' + asunum + '.')

                                    except Exception as exc:
                                        if len(exc.args) != 2:
                                            raise # Re-raise
                                            
                                        etype = exc.args[0]
                                        msg = exc.args[1]

                                        if etype == 'sitecode':
                                            setReqStatus(reqID, 'E', 'Unable to get site code for SUNUM ' + asunum + '.')
                                            logError(etype, msg)
                                            continue # Onto next request.
                                        else:
                                            raise # Re-raise
                                    
                                    # Always set request's status to 'P'. This request will not be checked on until the next iteration of the main loop of
                                    # the daemon.
                                    setReqStatus(reqID, 'P', None)
                                    
                                    # We may have new requests for offline SUs that are not being processed already. Start processing those SUs.
                                    for url in siteSunums:
                                        # Sort SUNUMS.
                                        siteSunums[url].sort()
                            
                                        # We gotta wait until there is a processing slot open before we can start downloading a new SU.
                                        newDownload(cursor, url, siteSunums[url])

                    
                            # Check on pending requests. Iterate through all SUs. If at least one is still being processed, then skip that request for now.
                            # If all are complete or online, then set the request record's status to 'C', and at the same time decrement the refcount on the SU.
                            # If the refcount becomes zero, then delete the SU's record from the SU table.
                            if len(pendingRequests) > 0:
                                requestPending = False
                                for arequest in pendingRequests:
                                    reqID = record[0]
                                    sunumsStr = record[1]
                                    reqStatus = record[2]
                        
                                    sunumList = sunumsStr.split(',')
                            
                                    # Check for completion of the processing of the requested SUs.
                                    for asunum in sunumList:
                                        if sunumBeingProcessed(asunum):
                                            requestPending = True
                                            break
        
                                    if not requestPending:
                                        # Set request's status to 'C', but first decrement the refcount on all SUs. If any SU's refcount reaches zero, then delete the SU record.
                                        if sus is None:
                                            sus = readSus()

                                        for asunum in sunumList:
                                            sus[asunum]['refcount'] = sus[asunum]['refcount'] - 1
                                            if sus[asunum]['refcount'] == 0:
                                                del sus[asunum]
                                
                                        setReqStatus(reqID, 'C', None)



                except psycopg2.Error as exc:
                    # Closes the cursor and connection
                    print('Unable to connect to the database', file=sys.stderr)
                    print(exc.diag.message_primary, file=sys.stderr)
        
                    # No need to close cursor - leaving the with block does that.
                    rv = RET_DBCONNECT

        except Exception as exc:
            if len(exc.args) != 2:
                raise # Re-raise
    
            etype = exc.args[0]
            msg = exc.args[1]
    
            if etype == 'drmsLock':
                print('Error locking file: ' + lockFile + '\n' + msg, file=sys.stderr)
                rv = RET_LOCK
                      
sys.exit(rv)
