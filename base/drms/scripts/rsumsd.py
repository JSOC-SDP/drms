#!/usr/bin/python

from __future__ import print_function
import sys
import re
import os
import stat
import filecmp
import thread
import psycopg2
import threading
from drmsCmdl import CmdlParser
from subprocess import check_output, CalledProcessError

# There are three database tables: 1., a DRMS site table, 2., a request table, and 3., an SU table. The site table (sitename, sitecode, baseurl) provides
# the information needed to query the providing site for the information needed to scp the requested SUs to the requesting site. The URL to the cgi
# program that provides scp information is formed by appending "rs.py" to baseurl. There are two parameters for this cgi: 1., "requestid", and 2., "sunums".
# During the initial request to the providing site, the requesting site will provide a requestid of "none", and a comma-separated list of SUNUMs
# in the sunums argument. Should the providing site have all the requested SUs online, then it will return the scp information needed to access those
# SUs, and a status of "complete". If, however, the SUs are not all online, the initial request will start an asynchronous tape-read of the offline SUs,
# returning a request ID that identifies the initial request, and a status of "pending". The requesting site must then poll for completion by
# periodically calling the cgi with a status request. To make a status request, the requestid argument contains the requestid returned by the
# inital CGI call, and the sunums argument contains "none". While the data are not ready, the status request returns a status of "pending". When
# the data are online, the status request returns a status of "complete".
#
# The request table (requestid, sunums, status) is populated by drms_storageunit.c. For all SUs that are offline and are not owned by the running
# DRMS/SUMS, the code inserts a record into the request table. The requestid is a UUID (within the running DRMS/SUMS) generated by a sequence table.
# The list of SUNUMs is put in sunums, and the initial status is set to 'N' (New request). drms_storageunit.c chunks such SUNUMs into
# manageable-sized requests. After inserting one or more such records into the request table, drms_storageunit.c then polls these records,
# waiting for the status to become 'C' (Complete request). After that happens, drms_storageunit.c then calls SUM_get() again on these SUs
# to obtain their paths. This daemon, rsumsd.py, periodically and reads all records in the request table. For each SU in each 'N' record
# (a single request, which could be requesting multiple SUs) the daemon first checks if the SU is already being processed. If so, then
# the SU table is not modified. The status of the record in the request table is set to 'P'. If the SU is not in the SU table, then
# this can mean one of two things. The daemon has never processed this SU, or the daemon has already processed this SU. When the daemon has completed
# processing an SU, it deletes the record for the SU from the SU table. If the latter is true, the daemon should not re-process the same SU. To distinguish
# between these two possibilities, the daemon first checks to see if the SU is already present in SUMS (it calls show_info -o sunum=SUNUM).
# If the SU is online, then the daemon does nothing. But if it is offline, then the daemon inserts a record for the SU into the SU table, and starts
# processing that SU. The status of that SU-table record is set to 'P', as is the status of the request record containing that SUNUM.
#
# For each SU in each 'P' request record, the daemon searches for records in the SU table. If one or more such records exist in the SU table, then
# the request record is left in the pending state. The next time the daemon scans the request records, it will again check the SU table looking
# for completion of all SUs. When that occurs, the status of the request record is set to 'C', indicating that the request is complete. The
# drms_storageunit.c code will then call SUMS to get the newly created paths to the requested SUs.

class SuTable():

    def __init__(self, cursor, tableName):
        self.cursor = cursor
        self.tableName = tableName
        self.suDict = {}
        
    def setCursor(cursor):
        self.cursor = cursor

    def read():
        # sus(sunum, refcount, status, message)
        cmd = 'SELECT sunum, refcount, status FROM ' + self.tableName
    
        try:
            self.cursor.execute(cmd)
    
        except psycopg2.Error as exc:
            raise Exception('sql', exc.diag.message_primary, cmd)
    
        for record in cursor:
            self.suDict[record[0]] = {}
            self.suDict[record[0]]['refcount'] = record[1]
            self.suDict[record[0]]['status'] = record[2]

    def write(sus):
        # sus(sunum, refcount, status, message)
        try:
            cursor.execute('PREPARE preparedStatement AS INSERT INTO ' + suTable + ' VALUES($1, $2, $3, $4)')
            for key in sorted(sus.iterkeys()):
                cursor.execute('EXECUTE preparedstatement (%s, %s, %s)', (key, sus[key]['refcount'], sus[key]['status']), sus[key]['msg'])
    
        except psycopg2.Error as exc:
            raise Exception('sql', exc.diag.message_primary, cmd)

    def setStatus(sunum, code, msg):
        self.suDict[sunum]['status'] = code
        if msg is not None:
            self.suDict[sunum]['status'] = msg
        else:
            self.suDict[sunum]['status'] = ''


# Downloads a single SU. Ingests it into SUMs (SUMS allows to ingestion of a single SU at a time only.). Updates
# the SU table status for that SU.
class Downloader(threading.Thread):
    tSeq = 0
    tList = [] # A list of running thread IDs.
    compSunum = -1 # The SUNUM of the SU just processed.
    maxThreads = 16 # A constant.
    eventMaxThreads = threading.Event() # Event fired when the number of threads decreases.
    eventSunum = threading.Event() # Event fired when compSunum gets set to -1.
    lock = threading.Lock() # Guard tList, compSunum, and tSeq guard.

    def __init__(self, sunum, path, suTable, scpPort, scpUser, scpHost, binPath):
        threading.Thread.__init__(self)
        Downloader.lock.acquire()
        self.threadnum = Downloader.tSeq # Thread ID.
        Downloader.tSeq += 1
        Downloader.lock.release()
        self.sunum = sunum
        self.path = path
        self.suTable = suTable
        self.scpPort = scpPort
        self.scpUser = scpUser
        self.scpHost = scpHost
        self.binPath = binPath

    def run(self):
        # Download the SU.
        
        # Don't forget to make the temporary directory first.
        cmdList = ['scp', '-r', '-P', self.scpPort, self.scpUser + '@' + self.scpHost + ':' + self.path + '/*', '/tmp/.su' + str(self.sunum)]
        try:
            check_call(cmdList)
        except CalledProcessError as exc:
            raise Exception('scp', "Command '" + ' '.join(cmdList) + "' returned non-zero status code " + str(exc.returncode))

        # Ingest the SUs into SUMS. size matters not...look at me...judge me by my size, do you?
        cmdList = [binPath + '/vso_sum_alloc', 'sunum=' + str(self.sunum), 'size=1024']
        try:
            resp = check_output(cmdList)
            output = resp.decode('utf-8')
        except CalledProcessError as exc:
            raise Exception('vso_sum_alloc', "Command '" + ' '.join(cmdList) + "' returned non-zero status code " + str(exc.returncode) + '.')
        
        regExp = re.compile(r'.+sudir:(\S+)')
        matchObj = regExp.match(output)
        if matchObj is not None:
            sudir = matchObj.group(1)
        else:
            raise Exception('vso_sum_alloc', "Command '" + ' '.join(cmdList) + "' printed unexcepted output " + output + '.')
        
        cmdList = ['mv', '/tmp/.su' + str(self.sunum) + '/*', sudir]
        try:
            check_call(cmdList)
        except CalledProcessError as exc:
            raise Exception('mv', "Command '" + ' '.join(cmdList) + "' returned non-zero status code " + str(exc.returncode))
        
        # Remove temporary directory.
        
        # Update SU table. Set SU-table record status to 'C'.
        suTable.setStatus(self.sunum, 'C', None)
        
        # This thread is about to terminate.
        
        # Each thread must block if compSunum != -1. compSunum == 1 ==> an SU just got downloaded, and
        # we need to pass the SUNUM of the SU just downloaded to the main thread before any other
        # thread can be allowed to terminate. We also need to check the class tList variable to update it.
        # For both reasons, we must acquire the lock.
        Downloader.lock.acquire()
        
        while Downloader.compSunum != -1:
            Downloader.lock.release()
            Downloader.eventSunum.wait()
            Downloader.lock.acquire()
        
        Downloader.tList.remove(self) # This thread is no longer one of the running threads.
        if len(Downloader.tList) == Downloader.maxThreads - 1:
            # Fire event so that main thread can add new SUs to the download queue.
            Downloader.eventMaxThreads.set()
            # Clear even so that main will block the next time it calls wait.
            Downloader.eventMaxThreads.clear()

        Downloader.compSunum = self.sunum

        
        Downloader.lock.release()


def GetArgs(args):
    istat = False
    optD = {}
    
    parser = CmdlParser(usage='%(prog)s [ -h ] cfg=<DRMS/SUMS configuration file> sutable=<storage unit table> reqtable=<request table> [ --dbname=<db name> ] [ --dbhost=<db host> ] [ --dbport=<db port> ]')
    
    # Required parameters.
    parser.add_argument('c', 'cfg', '--cfg', help='', metavar='<configuration file>', dest='cfg', required=True)
    parser.add_argument('s', 'sutable', '--sutable', help='The database table that contains records of the storage units being processed.', metavar='<storage unit table>', dest='sutable', required=True)
    parser.add_argument('r', 'reqtable', '--reqtable', help='The database table that contains records of the SU-request being processed.', metavar='<request unit table>', dest='reqtable', required=True)
    
    # Optional parameters.
    parser.add_argument('-N', '--dbname', help='The name of the database that contains the series table from which records are to be deleted.', metavar='<db name>', dest='dbname', default='jsoc')
    parser.add_argument('-H', '--dbhost', help='The host machine of the database that contains the series table from which records are to be deleted.', metavar='<db host machine>', dest='dbhost', default='hmidb')
    parser.add_argument('-P', '--dbport', help='The port on the host machine that is accepting connections for the database that contains the series table from which records are to be deleted.', metavar='<db host port>', dest='dbport', default='5432')
  
    try:
        args = parser.parse_args()
          
    except Exception as exc:
        if len(exc.args) == 2:
            type = exc[0]
            msg = exc[1]
                  
            if type != 'CmdlParser-ArgUnrecognized' and type != 'CmdlParser-ArgBadformat':
                raise # Re-raise
                  
            print(msg, file=sys.stderr)
            istat = False
              
        else:
            raise # Re-raise
  
    if not istat:
        try:
            optD['cfg'] = args.cfg
            optD['sutable'] = args.sutable
            optD['reqtable'] = args.reqtable
            optD['dbname'] = args.dbname
            optD['dbhost'] = args.dbhost
            optD['dbport'] = args.dbport
    
        except KeyError as exc:
            type, value, traceback = sys.exc_info()
            print(exc.strerror, file=sys.stderr)
            istat = False
    
    return optD


def filterSunums(sunumList, sus, jfPath):
    rv = []
    
    # Pass SUNUM only if it is offline and not being current processed.
    notBeingProcessed = [ sunum for sunum in sunumList if not sunum in sus ]
    if len(notBeingProcessed) > 0:
        # There is not an efficient way to check for the SU being on/offline. But we can use jsoc_info (vs. show_info - jsoc_info returns
        # JSON, which is handy). And it also can be called in a mode where it does not trigger a SUM_get() - it uses SUM_infoEx():
        #   op=exp_su requestid=NOASYNCREQUEST sunum=123456789 format=json formatvar=dataobj method=url_quick protocol=as-is
        cmd = jfPath + ' op=exp_su requestid=NOASYNCREQUEST format=json formatvar=dataobj method=url_quick protocol=as-is sunum=' + ','.join(notBeingProcessed)
    
        try:
            resp = check_output(cmd)
            output = resp.decode('utf-8')
    
        except ValueError:
            raise Exception('jfetch', "Unable to run command: '" + ' '.join(cmd) + "'.")
        except CalledProcessError as exc:
            raise Exception('jfetch', "Command '" + ' '.join(cmd) + "' returned non-zero status code " + str(exc.returncode))

        offline = []
        jsonObj = json.loads(output)
        for sunum in jsonObj['data']:
            if jsonObj['data'][sunum]['sustatus'] == 'N':
                offline.append(sunum)
                    
        rv = offline
    else:
        rv = notBeingProcessed

    return rv

def newDownload(cursor, url, sunumList):


# Process the SUs for the source site represented by url.
# url - the URL (base URL plus cgi arguments, except for the sunum= argument) from which SU paths can be obtained.
# sunums - a list of sorted SUNUMs to download.
def processSU(dbconn, url, sunums):

    # Create the sunum= argument.




# Break-up large requests from a single URL into multiple smaller requests.
nElems = len(sunums[url])
if nElems > MAX_SUS:
    lastChunk = False
else:
    lastChunk = True

while nElems > MAX_SUS or lastChunk:
    sunumChunk = sunums[]
    if lastChunk:
        nElems = 0
    else:
        nElems -= MAX_SUS


if __name__ == "__main__":
    optD = {}

    # Use a pid file to ensure that only a single instance is running.

    if rv == RET_SUCCESS:
        # Connect to the database
        try:
            # The connection is NOT in autocommit mode. If changes need to be saved, then conn.commit() must be called.
            with psycopg2.connect(database=optD['dbname'], user=optD['dbuser'], host=optD['dbhost'], port=optD['dbport']) as conn:
                with conn.cursor() as cursor:
                    reqTable = optD['reqtable']

                    sites = None
                    requests = None
                    sus = None
                    
                    cmd = 'SELECT requestid, sunums, status FROM ' + reqTable
                    try:
                        cursor.execute(cmd)
            
                    except psycopg2.Error as exc:
                        raise Exception('sql', exc.diag.message_primary, cmd)
            
                    requests = cursor.fetchall()
                    
                    # Iterate through returned records. Need to split the requests into two lists: a list of new requests, and a list of
                    # pending requests.
                    newRequests = []
                    pendingRequests = []
                    for arequest in requests:
                        if arequest[3] == 'N':
                            newRequests.append[arequest]
                        else:
                            pendingRequests.append[arequest]
                    
                    siteUrls = {}
                    siteSunums = {} # New sunum CGI requests to providers.
                    
                    # Process new requests
                    if len(newRequests) > 0:
                        # We will need to map SUNUMs to site base URLs, so load up the sites table.
                        cmd = 'SELECT sitecode, baseurl FROM ' + siteTable
                        try:
                            cursor.execute(cmd)

                        except psycopg2.Error as exc:
                            raise Exception('sql', exc.diag.message_primary, cmd)
                            
                        sites = cursor.fetchall()
                            
                        for asite in sites:
                            code = asite[0]
                            siteUrls[code] = asite[1]
                         
                        for arequest in newRequests:
                            reqID = record[0]
                            sunumsStr = record[1]
                            reqStatus = record[2]
                        
                            sunumList = sunumsStr.split(',')
                            
                            chunker = Chunker(sunumList)
                            try:
                                # Request from providers, but only if the SUNUM has not already been processed and is not currently being processed.
                                for chunk in chunker:
                                    sunumList = chunk.getItems()

                                    # Filter out SUs that are being processed, or already online.
                                    sunumListOffline = filterSunums(sunumList)
                                
                                    # Organize SUNUMs by owning site.
                                    for asunum in sunumListOffline:
                                        code = getSiteCode(asunum)
                                        if code is not None:
                                            url = siteUrls[code]
                                            if url not in siteSunums:
                                                siteSunums[url] = []
                                    
                                            siteSunums[url].append(asunum)
                                        else:
                                            # Could not obtain site code - error.
                                            raise Exception('request', 'Error request ID ' + reqID + '. Unable to get site code for SUNUM ' + asunum + '.')

                            except Exception as exc:
                                if len(exc.args) != 2:
                                    raise # Re-raise
                                        
                                etype = exc.args[0]
                                msg = exc.args[1]
                                        
                                setReqStatus(reqID, 'E', 'Unable to get site code for SUNUM ' + asunum + '.')
                                logError(etype, msg)
                                continue # Onto next request.
                                
                            # Always set request's status to 'P'. This request will not be checked on until the next iteration of the main loop of
                            # the daemon.
                            setReqStatus(reqID, 'P', None)
                                
                            # We may have new requests for offline SUs that are not being processed already. Start processing those SUs.
                            for url in siteSunums:
                                # Sort SUNUMS.
                                siteSunums[url].sort()
                        
                            # We gotta wait until there is a processing slot open before we can start downloading a new SU.
                            newDownload(cursor, url, sunums[url])


                    
                    
                    
                
                    # Check on pending requests. Iterate through all SUs. If at least one is still being processed, then skip that request for now.
                    # If all are complete or online, then set the request record's status to 'C', and at the same time decrement the refcount on the SU.
                    # If the refcount becomes zero, then delete the SU's record from the SU table.
                    if len(pendingRequests) > 0:
                        requestPending = False
                        for arequest in pendingRequests:
                            reqID = record[0]
                            sunumsStr = record[1]
                            reqStatus = record[2]
                    
                            sunumList = sunumsStr.split(',')
                        
                        # Check for completion of the processing of the requested SUs.
                        for asunum in sunumList:
                            if sunumBeingProcessed(asunum):
                                requestPending = True
                                break
    
                        if not requestPending:
                            # Set request's status to 'C', but first decrement the refcount on all SUs. If any SU's refcount reaches zero, then delete the SU record.
                            if sus is None:
                                sus = readSus()

                            for asunum in sunumList:
                                sus[asunum]['refcount'] = sus[asunum]['refcount'] - 1
                                if sus[asunum]['refcount'] == 0:
                                    del sus[asunum]
                            
                            setReqStatus(reqID, 'C', None)



        except psycopg2.Error as exc:
            # Closes the cursor and connection
            print('Unable to connect to the database', file=sys.stderr)
            print(exc.diag.message_primary, file=sys.stderr)
    
            # No need to close cursor - leaving the with block does that.
            rv = RET_DBCONNECT
