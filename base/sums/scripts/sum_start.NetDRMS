#!/usr/bin/perl -w
#sum_start.NetDRMS
#This is to start the sum_svc and multiple related servers on a remote site.
#Call with -M will not send mail notification (N/A on NetDRMS).
#Call with -f to force a stop if needed (vestigial). 
#

use FindBin qw($RealBin);
# use 5.010_000; # See ExtractVal() - if you don't want to upgrade to 5.10, uncomment lines in this routine.

$| = 1;                 #flush output as we go

use constant PID_FILE => "sums.pidfile";

$mailflg = 1;
$forceflg = 0;
$forcearg = "";

if ($#ARGV >= 0)
{
   while ($ARGV[0] =~ /^-/) {
      $_ = shift;
      if (/^-M(.*)/) {
         $mailflg = 0;
      }
      elsif(/^-f(.*)/) {
         $forceflg = 1;
         $forcearg = "-f";
      }
      else {
         print "Illegal switch\n";
         exit;
      }
   }
}

$wdpath = $RealBin;

$ldir = "$wdpath/../../../include/localization.h";
$sdir = "$wdpath/../../drms/apps/serverdefs.h";

if(-e $ldir) {
  $xdir = $ldir;
  $localization = 1;
}
else {
  $xdir = $sdir;
  $localization = 0;
}

@servdefs = `cat $xdir`;

@def = grep(/^#define SUM_NUMSUM/, @servdefs);
$numsum = ExtractVal($def[0]);
if(!defined($numsum) || !$numsum) {
  print "ERROR: Can't get SUM_NUMSUM from $xdir\n";
  exit(1);
}
print "Number of SUM process sets to spawn = $numsum\n";

@def = grep(/^#define SUM_MAXNUMSUM/, @servdefs);
$maxnumsum = ExtractVal($def[0]);
print "Max number of SUM process can spawn = $maxnumsum\n";

if($numsum == 0 || !defined($maxnumsum) || $numsum > $maxnumsum) {
  print "**ERROR: in $xdir def for SUM_NUMSUM\n";
  print "Number must be between 1 and $maxnumsum\n";
  exit;
}

@def = grep(/^#define SUMSERVER/, @servdefs);
$sumserver = ExtractVal($def[0]);

$host = `hostname`;
chomp($host);
if(($pos = index($host, '.')) != -1) {
  $host = substr($host, 0, $pos);
}
if($host ne $sumserver) {
  print "This can only be run on $sumserver.\n";
  exit;
}

$ENV{'SUMSERVER'} = $sumserver;      #make sure we stay in this machine
print "SUMSERVER is $sumserver\n";

@def = grep(/^#define SUMS_MANAGER/, @servdefs);
$sumsmanager = ExtractVal($def[0]);
print "SUMS_MANAGER is $sumsmanager\n";
$user = $ENV{'USER'};
if($user ne $sumsmanager) {
  print "You must be user $sumsmanager to run\n";
  exit;
}
@def = grep(/^#define SUMS_MANAGER_UID/, @servdefs);
$sumsmanageruid = ExtractVal($def[0]);
print "SUMS_MANAGER_UID is $sumsmanageruid\n";
$GREPPS = $sumsmanageruid;

@def = grep(/^#define DBNAME/, @servdefs);
$dbname = ExtractVal($def[0]);
$DB = $dbname."_sums";
print "SUMS db is $DB\n";

@def = grep(/^#define SUMLOG_BASEDIR/, @servdefs);
$logDir = ExtractVal($def[0]);
print "SUMS log dir is $logDir\n";

$PID = getppid;
$LOGFILE = "/tmp/sum_start.NetDRMS.$PID";
open(LOG, ">$LOGFILE") || die "Can't open $LOGFILE: $!\n";
($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
$sec2 = sprintf("%02d", $sec);
$min2 = sprintf("%02d", $min);
$hour2 = sprintf("%02d", $hour);
$mday2 = sprintf("%02d", $mday);
$mon2 = sprintf("%02d", $mon+1);
# $year2 = sprintf("%02d", $year);
$date = (1900 + $year).".".$mon2.".$mday2"._.$hour2.":$min2".":$sec2";
$dtag = (1900 + $year).".".$mon2.".$mday2".".$hour2"."$min2"."$sec2"; #for log name
$sumlog = "sum_svc_$dtag.log";
$sumrmlog = "sum_rm_$dtag.log";
print "sum_start.NetDRMS at $date\n\n";
print LOG "sum_start.NetDRMS at $date\n\n";

@ps_prod = `ps -ef | grep $GREPPS`;
#print "The ps -ef for producttion is:\n@ps_prod\n";
print LOG "The ps -ef for product is:\n@ps_prod\n";

# Find if any sums process is still running (by looking for the sums.pidfile file).
# Set $active=1 if so.

$active = 0;

$pidFile = $logDir . "/" . &PID_FILE;
if (-e $pidFile)
{
    $active = 1;
}

  if($active) {
    print "** NOTE: SUMS is already running\n";
    print LOG "** NOTE: SUMS is already still running\n";
    print "Do you want me to do a sum_stop.NetDRMS followed by a sum_start.NetDRMS (y or n):\n";
    while(<STDIN>) {
      chop($_);
      if(($_ eq "Y") || ($_ eq "y")) {
        last;
      }
      else {
        print "Aborting sum_start.NetDRMS\n";
        exit;
      }
    }
      
      # sum_stop.NetDRMS will shutdown all SUMS processes and remove the SUMS pidfile.
    if($mailflg) {
      $cmd = "sum_stop.NetDRMS $forcearg";
    }
    else {
      $cmd = "sum_stop.NetDRMS -M $forcearg";
    }
    if(system($cmd)) {
      print "Error: failure on sum_stop.NetDRMS\n";
      exit;
    }
  }


#For tape_svc only
#        $cmd = "ssh d02.stanford.edu sum_forker  $DB $date&";
#        if(system($cmd)) {
#          print "Error: failure on $cmd\n";
#        }

        print "** Now starting SUMS on $DB\n";
        print LOG "** Now starting SUMS on $DB\n";

        #$cmd = "/home/production/cvs/JSOC/base/sums/scripts/sumck_ximM &";
        # Since there is no SUMS pidfile, this script will launch all SUMS processes afresh, and create a pidfile.
        $cmd = "sums_procck.py &";
        $ret = system($cmd);
        if ($ret == -1) 
        {
          print STDERR "Error: failed to run $cmd.\n";
        }
        elsif ($ret & 127)
        {
            print STDERR "Error: $cmd died on unhandled signal " . $ret & 127 . "\n."
        }
        
        print "SUM NetDRMS Start Complete\n";
        print LOG "SUM NetDRMS Start Complete\n";
        close(LOG);
#        $mail = "mail -s \"SUM xim MULTI Start Complete\"";
#        #$to = "jsoc_users";
#        $to = "jim\@sun.stanford.edu";
#        $cmd = "$mail $to < $MLOGFILE";
#        if($mailflg) { system $cmd; }
        exit;

sub ExtractVal
{
   my($line) = $_[0];

   # requires Perl version 5.10
   #my($val) = ($line =~ /^#define\s+\S+\s+(?|\"([^\s\."]+)(\..*)?\"|([^\s\.]+)(\..*)?)\s*/)[0];

   # alternate that will work on Perl version 5.8
   #my($val);
   #if ($line =~ /^#define\s+\S+\s+\"([^\s\."]+)(\..*)?\"/)
   #{
   #   $val = $1;
   #}
   #elsif ($line =~ /^#define\s+\S+\s+([^\s\.]+)(\..*)?\s*/)
   #{
   #   $val = $1;
   #}

   # Igor's regex
   my($val) = ($line =~ /^#define\s+\S+\s+"?([^"\s\.]+)(\.(.*))?/);

   return $val;
}
