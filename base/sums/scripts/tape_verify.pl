#!/usr/bin/perl -w

#-------------------------------------------------------------------------------------
#
# tape_verify.pl
#
# This script scans IMPORT/EXPORT slots (26-30) for tapes.
# Each tape is transferred to the TAPE DRIVE where each file is read and a md5 check sum is calculated.
# The check sums are saved into a file (ex: 000822L4.md5_offsite)
# After all tapes have been scanned, the check sums generated offsite will be compaired with 
# check sums generated onsite at Stanford to verify that the tapes are not dammaged after being transported.
# A summary report for each tape is written to a file to be sent back to Stanford for acknowlegements.
#
# For example:
#
# 000822L4.md5                     (generated onsite) 
# 000822L4.md5_offsite             (generated offsite)
# HMI_2008.05.12_14:00:00:00.ver   (verify summary report)
#
#-------------------------------------------------------------------------------------


use strict;

my $OFF_SITE_TAPE_VERIFICATION_DEBUG_MESSAGES = 1;
my $original_tape_positions;

TapeVerify();

exit; 


#-------------------------------------------------------------------------------------
# TapeVerify()
#
# Scan IMPORT/EXPORT slots (26-30).
# For each tapes, scan all files and generate one "tape_label.md5_offsite" file (ie:000001L3.md5_offsite)
#

sub TapeVerify
{
    my ($tapes_in_slots, $tape_label, $filename, $number_of_files, %tapes, @tape_list);

    $tapes_in_slots = InitCheck();


    # Create a hash containing tape_labels and number_of_files
    # Look for correspondent md5 files previously generated onsite for a particular tape, 
    # if missing, skip that tape (by not including that tape_label in %tapes)

    DebugMessage("Search for correspondent .md5 files previously generated onsite.\n");
    %tapes=();

    foreach $tape_label (@$tapes_in_slots)
    {
	$filename = $tape_label . ".md5";
	$number_of_files = 0;

	if (-e $filename) # if file exist
	{
	    open(FILE, "<$filename") or die "can't open $filename: $!";
	    $number_of_files++ while <FILE>;
	    close(FILE);

	    if($number_of_files)
	    {
		$tapes{$tape_label} = $number_of_files-1; # not counting the first comment line
	    }
	}
    }

    @tape_list = sort keys (%tapes); # good list




    # Show the list of tapes to be verified
    DebugMessage("Tapes to be verified : ");
    foreach $tape_label (@tape_list)
    {
	DebugMessage(" $tape_label");
    }
    DebugMessage("\n");




    # Scan each tape, generate "tape_label.md5_offsite" file
    foreach $tape_label (@tape_list)
    {
	ProcessTape($tape_label, $tapes{$tape_label});
    }


    # Compare "tape_label.md5" to "tape_label.md5_offsite" and write "verify summary report"
    CompareFilesAndReport(\@tape_list);


    DebugMessage("TapeVerify() finished successfully.\n");

}

#-------------------------------------------------------------------------------------
# InitCheck()
#
# Save orginial_tape_positions.
# If there is tape in SLOT 0, unload it to an open slot in (1-25)
#


sub InitCheck
{
    my ($current_tape,$current_tape_positions, @process_list, $slot);

    $original_tape_positions = GetCurrentTapePositions();
    DisplayTapePositions($original_tape_positions);

    $current_tape = GetCurrentTapeLabel();
    if($current_tape) 
    {
	UnloadTape($original_tape_positions);
	$current_tape_positions = GetCurrentTapePositions();
	DisplayTapePositions($current_tape_positions);
    }
    
    for($slot=26;$slot <31;$slot++)
    {
	if($original_tape_positions->{$slot}) 
	{
	    push(@process_list, $original_tape_positions->{$slot});     
	}
    }

    return \@process_list;
}

#-------------------------------------------------------------------------------------
# ProcessTape (tape_label, number_of_files = 10)
#
# LoadTape() into SLOT 0
# Retension Tape
# Scan Tape for files, get MD5s and save them into file "$tape_label.md5_offsite" (ie: 000828L4.md5_offsite)
# UnloadTape() back to the original position
#

sub ProcessTape
{
    my $tape_label = $_[0];
    my $number_of_files = defined($_[1]) ? $_[1] : 10;

    my ($command, $check_sum, $i);


    DebugMessage("LoadTape($tape_label)\n");
    LoadTape($tape_label);


    #DebugMessage("RetensionTape\n");
    #$command = "mt -f /dev/nst0 retension";
    #system($command)==0 || die "ProcessTape() fails. ";  


    DebugMessage("RewindTape\n");
    $command = "mt -f /dev/nst0 rewind";
    system($command)==0 || die "ProcessTape() fails. ";  


    # Skip first file (contains only the Tape Label - no data)
    $command = "mt -f /dev/nst0 fsf 1";
    system($command)==0 || die "ProcessTape() fails. ";  


    open(OUTFILE,">$tape_label.md5_offsite") || die "ProcessTape() fails: $!";
    print OUTFILE "# $tape_label.md5_offsite generated by tape_verify.pl at " . GetTimeString() ."\n";

    
    for($i=1;$i<=$number_of_files;$i++)
    {

	$check_sum = GetCheckSum();

	if($check_sum)
	{
	    print OUTFILE "$i $check_sum\n";
	    DebugMessage("GetCheckSum($tape_label:$i) => [$check_sum]\n");
	}
	else { last;} # something wrong
    } 

    close (OUTFILE);



    DebugMessage("RewindTape\n");
    $command = "mt -f /dev/nst0 rewind";
    system($command)==0 || die "ProcessTape() fails. ";  


    DebugMessage("UnloadTape($tape_label)\n");
    UnloadTape($original_tape_positions);

}

#-------------------------------------------------------------------------------------
# LoadTape (tape_label)
#
# Look up the current tape positions to see where the tape_label is, 
# load it into SLOT 0
#

sub LoadTape
{
    my $tape_label = $_[0];
    my($current_tape_positions, $slot, $label, $found_slot,$command);
    

    $current_tape_positions = GetCurrentTapePositions();

    while (($slot, $label) = each %$current_tape_positions) 
    {
	if($label eq $tape_label) 
	{
	    $found_slot = $slot;
	    last;
	}
    }
    
    if($found_slot)
    {
	$command = "mtx -f /dev/t50 load $found_slot 0";
	system($command)==0 || die "LoadTape($tape_label) fails =>";  
    }
    else
    {
	print "LoadTape($tape_label) tape not found\n";
	print "Here is the list of currently available tapes:\n";
        DisplayTapePositions($current_tape_positions);
    }
    
}

#-------------------------------------------------------------------------------------
# UnloadTape (original_tape_positions)
# 
# if tape is originally from one of IMPORT/EXPORT slots, place it back to the original slot.
# else tape is originally from one of internal slots, place it in an open slot (1-25).

sub UnloadTape
{

    my $original_tape_positions = $_[0];
    my ($current_tape, $slot, $label, $found_slot, $command);

    $found_slot = undef;

    $current_tape = GetCurrentTapeLabel();
    if(!$current_tape) # no tape in SLOT #0
    {
	return;
    }
    
    while (($slot, $label) = each %$original_tape_positions) 
    {
	if($label eq $current_tape)
	{
	    $found_slot = $slot;
	    last;
	}
    }

    if(! $found_slot)
    {
	for($slot=1;$slot <26;$slot++)
	{
	    if(!$original_tape_positions->{$slot}) 
	    {
		$found_slot = $slot;
		last;
	    }
	}
    }
    

    if(! $found_slot) 
    {
	die ("UnloadTape() could not find open slot to unload.\n");
    }

    # Move tape
    DebugMessage("UnloadTape() $current_tape to slot $found_slot.\n");

    $command = "mtx -f /dev/t50 unload $found_slot 0";
    system($command)==0 || die "UnLoadTape() fails =>";

    # Will get following response, if wanna check
    # "Unloading Data Transfer Element into Storage Element $found_slot...done".

}


#-------------------------------------------------------------------------------------
# DisplayTapePositions (\%tape_positions)
#
# Tape Positions: (3)
# slot[0] => tape[000829L4]
# slot[1] => tape[000822L4]
# slot[29] => tape[000828L4]


sub DisplayTapePositions
{
    my $hash = $_[0];
    my @order_keylist;
    my $key;

    @order_keylist = sort{$a <=> $b} (keys(%$hash));

    print "Tape Positions: (" . @order_keylist . " tapes)\n";  

    foreach $key (@order_keylist) 
    {
	print "slot[". $key ."] => tape[" . $hash->{$key} ."]\n";
    }
}

#-------------------------------------------------------------------------------------
# GetCurrentTapeLable in TAPE DRIVE (SLOT 0)
#
# return a tape label (ex: 000828L4) or undef if SLOT 0 is empty.
#


sub GetCurrentTapeLabel
{
    my ($line, $name, $value);

    $value = undef;
    open(COM,"mtx -f /dev/t50 status |") || die "GetCurrentTapeLabel() fails : $!";
    while (defined ($line = <COM>)) {
	chomp($line);
	if ($line =~ /Data Transfer Element 0/) 
	{
	    ($name, $value) = split( /=/,$line);
	    if($value) 
	    {
		$value =~ s/^\s+//;
		$value =~ s/\s+$//;
	    }
	    last;
	}
    }
    close(COM) || die "GetCurrentTapeLabel() fails : $!";

    return $value;
}

#-------------------------------------------------------------------------------------
# GetCurrentFileNumber asks TAPE DRIVE where we are on tape (ex: => 9)

sub GetCurrentFileNumber
{
    my ($line, $name, $value);

    $value = undef;
    open(COM,"mt -f /dev/nst0 status |") || die "GetCurrentFileNumber() fails : $!";
    while (defined ($line = <COM>)) {
	chomp($line);
	if ($line =~ /file number/)  # Where we are on the current TAPE
	{
	    ($name, $value) = split( /=/,$line);
	    $value =~s/^\s+//;
	    last;
	}
    }
    close(COM) || die "GetCurrentFileNumber() fails : $!";

    return $value;
}

#-------------------------------------------------------------------------------------
# GetCheckSum of the current file on TAPE DRIVE (Slot 0)
# Note: current file number will advanced to the next one.
#
# Note: Caller use this function to check END OF DATA as well
# This system command always return 0, even at the EOD (end of data) on TAPE. 
# Experiment => A blank block of tape return $check_sum = "d41d8cd98f00b204e9800998ecf8427e"
# For now, we use that as END OF DATA indicator, which return $checksum=undef


sub GetCheckSum
{
    my ($result, $checksum, $command);

    $checksum = undef;


    $command = "dd if=/dev/nst0 bs=256b 2>/dev/null | md5filter 256 current_md5 > /dev/null 2>err.log";
    $result = system($command);#==0 || die "GetCheckSum() fails : $!";

    if($result == 0)
    {    
	open(MD5_FILE,"<current_md5") || die "GetCheckSum()  fails: $!";

	if(defined ($checksum = <MD5_FILE>)) 
	{
	    chomp($checksum);

	    if($checksum eq "d41d8cd98f00b204e9800998ecf8427e")
	    {
		$checksum = undef;
	    }
	}

	close(MD5_FILE) || die "GetCheckSum() fails : $!";
    }

    #DebugMessage("GetCheckSum() => [$result] [$checksum]\n");

   return $checksum;
}

#-------------------------------------------------------------------------------------
# GetCurrentTapePositions: return tapes as a hash 
#
# where %tape_positions{"slot_number"} = "label" if there is a tape in slot number
#       %tape_positions("slot_number"} =  undef  if there is no tape in slot number
#
# ------------------------------------------------------------------------------------
# A sample output of Tape Robot "status" command
#
#  Storage Changer /dev/t50:1 Drives, 30 Slots ( 5 Import/Export )
#Data Transfer Element 0:Full (Storage Element 6 Loaded):VolumeTag = 000828L4
#      Storage Element 1:Full :VolumeTag=000829L4
#      Storage Element 2:Empty
#      ...
#      Storage Element 29 IMPORT/EXPORT:Empty
#      Storage Element 30 IMPORT/EXPORT:Full :VolumeTag=000822L4
#
#-------------------------------------------------------------------------------------

sub GetCurrentTapePositions
{
    my %tape_positions=();
    my ($line, $slot_number, $label);
    
    open(COM,"mtx -f /dev/t50 status |") || die "GetTapePositions() fails : $!";
    while (defined ($line = <COM>)) 
    {
	chomp($line);
	if ($line =~ /VolumeTag/) # look for slot with tape (line has "VolumeTag") 
	{

	    if($line =~ /Data Transfer Element 0/) 
	    {
		$slot_number = "0";
			
		$label = (split(/ = /,$line))[1];
		#$label =~ s/^\s+//;
		$label =~ s/\s+$//;
	    }
	    else
	    {
		$slot_number = (split/[ :]/,(split(/Storage Element /,$line))[1])[0];
		$label = (split(/=/,$line))[1];
		$label =~ s/\s+$//;

	    }
	    
	    #print "line=[$line]slot=[$slotno]label=[$label]\n";

	    $tape_positions{$slot_number} = $label;	    
	}
    }
    close(COM) || die "can't close $!";


    #foreach $key (sort keys(%tapes)) 
    #{
    #	print "GetTapeLabels ". $key . " => " . $tapes{$key} . "\n";
    #}

    return \%tape_positions;
}

#-------------------------------------------------------------------------------------
# usage: $string = getTimeString( [$time_t] ); Omit parameter for current time/date

sub GetTimeString
{
    
    @_ = localtime(shift || time);
    return(sprintf("%04d.%02d.%02d_%02d:%02d:%02d",$_[5]+1900,$_[4]+1,$_[3],$_[2],$_[1],$_[0]));
    #($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
}

#-------------------------------------------------------------------------------------
# DebugMessage($string)

sub DebugMessage 
{
    if ($OFF_SITE_TAPE_VERIFICATION_DEBUG_MESSAGES)
    {
	print $_[0];
    }
}

#-------------------------------------------------------------------------------------
# CompareFilesAndReport(\@tapelist)
#
# For each tape in the list, read check_sums generated onsite and offsite into strings.
# Compare each lines (checksums) on a tape. 
# If they all matched, report success(0) else false (1)
#
# For example:
#
# 000822.md5         (generated onsite) 
# 000822.md5_offsite (generated offsite)
# HMI_2008.05.12_14:00:00:00.ver (compared results)
#

sub CompareFilesAndReport
{
    my $tapelist = $_[0];

    my ($ver_filename, $tape_label , $verified, $i);
    my (@lines_1, @lines_2, $filename_1, $filename_2);


    
    $ver_filename = "HMI_" . GetTimeString() . ".ver";    
    open (FILE_OUT, ">>$ver_filename") || die "CompareAndReport() Can't Open : $ver_filename $!\n";
	
    print FILE_OUT "# Offsite verify offhost:dds/off2ds/" . $ver_filename . "\n";
    print FILE_OUT "# Tape   0=success\n";
    

    
    foreach $tape_label (@$tapelist)
    {
	$filename_1 = $tape_label . ".md5";
	$filename_2 = $tape_label . ".md5_offsite";

	# Check for missing files
	if(! open (FILE_IN_1,"<$filename_1") or ! open (FILE_IN_2,"<$filename_2"))
	{
	    close FILE_IN_1;
	    close FILE_IN_2;
	    print FILE_OUT "$tape_label 1\n";

	    next;
	}


	@lines_1 = <FILE_IN_1>;
	@lines_2 = <FILE_IN_2>;

	close FILE_IN_1;
	close FILE_IN_2;


	# Check for number of lines
    	if(scalar(@lines_1) != scalar(@lines_2))
	{
	    print FILE_OUT "$tape_label 1\n";	    
	    next;
	}


	# Check each lines (except the first comment lines)
	$verified = "0";
	for ($i = 1; $i < @lines_1; $i++) 
	{
	    if($lines_1[$i] ne $lines_2[$i])
	    {
		$verified = "1";
		last;
	    }	
	}

	print FILE_OUT "$tape_label $verified\n";
    }

    close FILE_OUT;
    
}

#-------------------------------------------------------------------------------------
# CompareHashesAndReport(\@tapelist)
#
# This is another way to compare 2 files if the line formats (spacings) are different between md5 and md5_offsite
#
# For each tape in the list (IMPORT/EXPORT slots), read check_sums generated onsite and offsite into hashes.
# Compare every check_sum (one for each file on tape)
# If they all matched, report success(0) else false (1)
#
# For example:
#
# 000822.md5         (generated onsite) 
# 000822.md5_offsite (generated offsite)
# HMI_2008.05.12_14:00:00:00.ver (compared results)
#

sub CompareHashesAndReport
{
    my $tapelist = $_[0];

    my ($ver_filename, $tape_label , $key, $value, $verified);
    my ($hash_1, $hash_2, $filename_1, $filename_2);


    
    $ver_filename = "HMI_" . GetTimeString() . ".ver";    
    open (FILE_OUT, ">>$ver_filename") || die "CompareAndReport() Can't Open : $ver_filename $!\n";
	
    print FILE_OUT "# Offsite verify offhost:dds/off2ds/" . $ver_filename . "\n";
    print FILE_OUT "# Tape   0=success\n";
    

    
    foreach $tape_label (@$tapelist)
    {
	$filename_1 = $tape_label . ".md5";
	$hash_1 = ReadMd5ToHash($filename_1);
	$filename_2 = $tape_label . ".md5_offsite";
	$hash_2 = ReadMd5ToHash($filename_2);

	
	# compare values 
	$verified = "0";
	while (($key, $value) = each %$hash_2)
	{

	    if($hash_1->{$key} ne $value)
	    {
		$verified = "1";
		last;
	    }

	    DebugMessage("[$value] and [" . $hash_1->{$key} ."] => $verified\n");

	}

	print FILE_OUT $tape_label ." ". $verified . "\n";
	
    }

    close FILE_OUT;
    
}

#-------------------------------------------------------------------------------------
# ReadMD5ToHash(filename) return a hash.
#
# The onsite and offsite md5 should be identical (except for the first line), 
# The first comment line can be used as validity check (or skip it)
#

sub ReadMd5ToHash
{
    
    my ($filename) = $_[0];
    my ($expected_first_line, $line, @items);
    my %check_sums=();



    open (FILE_IN, $filename) || die "Can't Open : $filename $!\n";
    
    $line = <FILE_IN>; chomp($line); # Read first line  


    #------------------------------------------------------------------------
    # Validity check by comparing the first line with what is expected

    if(0)
    {

	if (/.md5_offsite$/, $filename) {
	    $expected_first_line = $filename . " from offsite tape verification";
	}
	else {
	    $expected_first_line = "# /dds/socdc/" . $filename  . " from datacapture";	
	}
    
	if ($line ne $expected_first_line) 
	{
	    DebugMessage("Invalid $filename (first line differs from $expected_first_line)\n");
	    close FILE_IN;
	    return undef;
	}
    }
    #----------------------------------------------------------------



    # Read each line into a hash

    while (<FILE_IN>) 
    {

	#print $_;

	s/#.*//;            # ignore comments by erasing them
	next if /^(\s)*$/;  # skip blank lines
	chomp;              # remove trailing newline characters
	       
 	@items = split(/ /,$_);
        $check_sums { $items[0] } = $items[1];

    }
    
    close FILE_IN;

    #print "Number of items: " . keys(%check_sums) . "\n";
    #PrintHash(\%check_sums);
    
    return \%check_sums;             

}

#-------------------------------------------------------------------------------------



