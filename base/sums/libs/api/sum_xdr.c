/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <rpc/rpc.h>
#include <sum_rpc.h>

bool_t
xdr_nametype(xdrs, objp)
	XDR *xdrs;
	nametype *objp;
{
	if (!xdr_string(xdrs, objp, MAXSTRING)) {
		return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_keyseg(xdrs, objp)
        XDR *xdrs;
        keyseg *objp;
{
        if (!xdr_nametype(xdrs, &objp->name)) {
                return (FALSE);
        }
        if (!xdr_int(xdrs, &objp->key_type)) {
                return (FALSE);
        }
        switch (objp->key_type) {
        case 1:
                if (!xdr_nametype(xdrs, &objp->keyseg_u.val_str)) {
                        return (FALSE);
                }
                break;
        case -1:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_byte, sizeof(char), (xdrproc_t) xdr_char)) {
                        return (FALSE);
                }
                break;
        case -2:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_ubyte, sizeof(u_char), (xdrproc_t) xdr_u_char)) {
                        return (FALSE);
                }
                break;
        case -3:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_short, sizeof(short) , (xdrproc_t) xdr_short)) {
                        return (FALSE);
                }
                break;
        case -4:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_ushort, sizeof(u_short), (xdrproc_t) xdr_u_short)) {
                        return (FALSE);
                }
                break;
        case -5:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_int, sizeof(int), (xdrproc_t) xdr_int)) {
                        return (FALSE);
                }
                break;
        case -6:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_uint, sizeof(u_int), (xdrproc_t) xdr_u_int)) {
                        return (FALSE);
                }
                break;
        case -7:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_long, sizeof(long), (xdrproc_t) xdr_long)) {
                        return (FALSE);
                }
                break;
        case -8:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_ulong, sizeof(u_long), (xdrproc_t) xdr_u_long)) {
                        return (FALSE);
                }
                break;
	case -9:
		 if (!xdr_pointer (xdrs, (char **)&objp->keyseg_u.val_uint64, sizeof (uint64_t), (xdrproc_t) xdr_uint64_t))
			return FALSE;
		break;
	case -10:
		 if (!xdr_pointer (xdrs, (char **)&objp->keyseg_u.val_uint32, sizeof (uint32_t), (xdrproc_t) xdr_uint32_t))
			return FALSE;
		break;
        case -16:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_float, sizeof(float) , (xdrproc_t) xdr_float)) {
                        return (FALSE);
                }
                break;
        case -17:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_double, sizeof(double), (xdrproc_t) xdr_double)) {
                        return (FALSE);
                }
                break;
        case -32:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_FILE, sizeof(double), (xdrproc_t) xdr_double)) {
                        return (FALSE);
                }
                break;
        case -33:
                if (!xdr_pointer(xdrs, (char **)&objp->keyseg_u.val_time, sizeof(double), (xdrproc_t) xdr_double)) {
                        return (FALSE);
                }
                break;
        }
        return (TRUE);
}

bool_t
xdr_Rkey(xdrs, objp)
        XDR *xdrs;
        Rkey *objp;
{
  if(!xdr_pointer(xdrs, (char **)&objp->next, sizeof(struct Rkey),(xdrproc_t)xdr_Rkey)) {
    return(FALSE);
  }
  if(!xdr_keyseg(xdrs, &objp->key_segment)) {
    return(FALSE);
  }
  return(TRUE);
}


