/* SUMLIB_NC_PaRequest_AP.pgc
 returns the archive pending list
 */
#include <SUM.h>
#include <sum_rpc.h>
#include <soi_error.h>
#include <printk.h>

PADATA *NC_PaRequest_AP();

PADATA *NC_PaRequest_AP()
{
  EXEC SQL TYPE uint64_t IS unsigned long long;

EXEC SQL BEGIN DECLARE SECTION;
  char stmt[512];
  VARCHAR l_wd[80];
  VARCHAR l_eff_date[20];
  uint64_t l_sumid;
  int l_status;
  int group_id;
  int safe_id;
  uint64_t ds_index;
  int l_archsub;
  double l_bytes;
  char wd[80];
  char eff_date[20];
EXEC SQL END DECLARE SECTION;

PADATA *ap = NULL;
char STMT[] = "SELECT WD, SUMID, STATUS, BYTES, EFFECTIVE_DATE, ARCHIVE_SUBSTATUS, GROUP_ID, SAFE_ID, DS_INDEX FROM SUM_PARTN_ALLOC WHERE (STATUS = 4 OR STATUS = 32) and GROUP_ID IN (0,1,2,3,4,5,8,9,11,102,103,104,105) order by GROUP_ID limit 3400";

//char STMT[] = "SELECT WD, SUMID, STATUS, BYTES, EFFECTIVE_DATE, ARCHIVE_SUBSTATUS, GROUP_ID, SAFE_ID, DS_INDEX FROM SUM_PARTN_ALLOC WHERE (STATUS = 4 OR STATUS = 32) and GROUP_ID IN (4,5) limit 3400";

//char STMT[] = "SELECT WD, SUMID, STATUS, BYTES, EFFECTIVE_DATE, ARCHIVE_SUBSTATUS, GROUP_ID, SAFE_ID, DS_INDEX FROM SUM_PARTN_ALLOC WHERE (STATUS = 4 OR STATUS = 32) and GROUP_ID = 1 limit 10000";

int i;
int groupids[] = {0,1,2,3,4,5,102,103,104,105}; //!!TEMP
int numids = 10;				//!!TEMP

EXEC SQL INCLUDE sqlca;

    printk("NC_PaRequest_AP \n");  
    printk("Special Version for select group_ids\n");

    EXEC SQL WHENEVER SQLERROR GOTO sqlerror;

//for(i=0; i < numids; i++) {
for(i=0; i < 1; i++) {
  //sprintf(stmt, STMT, groupids[i]);
  sprintf(stmt, STMT);
     EXEC SQL WHENEVER SQLERROR GOTO sqlerror;
     EXEC SQL PREPARE query FROM :stmt;
     EXEC SQL DECLARE reqcursor CURSOR FOR query;
     EXEC SQL OPEN reqcursor;
     EXEC SQL WHENEVER NOT FOUND GOTO end_fetch;

  for(; ; ){
		EXEC SQL FETCH reqcursor INTO :l_wd, :l_sumid, :l_status, :l_bytes, :l_eff_date, :l_archsub, :group_id, :safe_id, :ds_index;

		strcpy(wd, l_wd.arr);
		strcpy(eff_date, l_eff_date.arr);

		switch(l_status) {    /* add the entry to the linked list */
		case DAAP:
		case DASAP:
		  setpadata(&ap, wd, l_sumid, l_bytes, l_status, l_archsub, eff_date, group_id, safe_id, ds_index);
		  break;
		default:
                  printk("\n this shouldn't happen \n");
		  break;
		 }
    }

end_fetch:
	EXEC SQL CLOSE reqcursor;
        EXEC SQL COMMIT;
    continue;		//get next groupid
    //return ap;
	
sqlerror:
    printk("Error in NC_PaRequest_AP\n");
    printk("% .70s \n", sqlca.sqlerrm.sqlerrmc);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL CLOSE reqcursor;
    EXEC SQL ROLLBACK WORK;
    //continue;		//get next groupid
    return NULL;
} //end for()
return ap;
}

