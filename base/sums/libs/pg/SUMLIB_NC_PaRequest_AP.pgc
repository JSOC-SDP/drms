/* SUMLIB_NC_PaRequest_AP.pgc
 returns the archive pending list
 */
#include <SUM.h>
#include <sum_rpc.h>
#include <soi_error.h>
#include <printk.h>

PADATA *NC_PaRequest_AP();

PADATA *NC_PaRequest_AP()
{
  EXEC SQL TYPE uint64_t IS unsigned long long;

EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR l_wd[80];
  VARCHAR l_eff_date[20];
  uint64_t l_sumid;
  int l_status;
  int group_id;
  int safe_id;
  uint64_t ds_index;
  int l_archsub;
  double l_bytes;
  char wd[80];
  char eff_date[20];
EXEC SQL END DECLARE SECTION;

PADATA *ap = NULL;

EXEC SQL INCLUDE sqlca;

    printk("NC_PaRequest_AP \n");  

    EXEC SQL WHENEVER SQLERROR GOTO sqlerror;

	EXEC SQL DECLARE palloc CURSOR FOR
		SELECT WD, SUMID, STATUS, BYTES, 
		EFFECTIVE_DATE, ARCHIVE_SUBSTATUS, 
		GROUP_ID, SAFE_ID, DS_INDEX
		FROM SUM_PARTN_ALLOC
		WHERE 
                STATUS = 4 OR STATUS = 32
 		limit 2000;
		//ORDER BY GROUP_ID limit 10000;

	EXEC SQL OPEN palloc;

    EXEC SQL WHENEVER NOT FOUND GOTO end_fetch; 
	
	for( ; ; ){
		EXEC SQL FETCH palloc INTO :l_wd, :l_sumid, :l_status, :l_bytes, :l_eff_date, :l_archsub, :group_id, :safe_id, :ds_index;

		strcpy(wd, l_wd.arr);
		strcpy(eff_date, l_eff_date.arr);

		switch(l_status) {    /* add the entry to the linked list */
		case DAAP:
		case DASAP:
		  setpadata(&ap, wd, l_sumid, l_bytes, l_status, l_archsub, eff_date, group_id, safe_id, ds_index);
		  break;
		default:
                  printk("\n this shouldn't happen \n");
		  break;
		 }
    }

end_fetch:
	EXEC SQL CLOSE palloc;
        EXEC SQL COMMIT;
    return ap;
	
sqlerror:
    printk("Error in NC_PaRequest_AP\n");
    printk("% .70s \n", sqlca.sqlerrm.sqlerrmc);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    return NULL;
}
