/* SUMLIB_Main_Update.pgc 
 *
 * Updates the sum_main db table when a sum_put() is called. Called from
 * putdo_1() in sum_svc_proc.c. Can only be called for a single SU at 
 * a time (i.e. reqcnt = 1). Returns 0 on success.
 * A input keylist looks like:
 * wd_0:   KEYTYP_STRING   /SUM1/D1703
 * dsix_0: KEYTYP_UINT64    1703
 * REQCODE:        KEYTYP_INT      7
 * DEBUGFLG:       KEYTYP_INT      1
 * bytes:  KEYTYP_DOUBLE              1.200000e+08
 * storage_set:    KEYTYP_INT      0
 * group:  KEYTYP_INT      65
 * username:       KEYTYP_STRING   production
 * history_comment: KEYTYP_STRING   this is a dummy history comment that is
 * greater than 80 chars long to check out the code
 * dsname: KEYTYP_STRING   hmi_lev1_fd_V
 * reqcnt: KEYTYP_INT      1
 * tdays:  KEYTYP_INT      5
 * mode:   KEYTYP_INT      1
 * uid:    KEYTYP_UINT64    888
 */
#include <SUM.h>
#include <sum_rpc.h>
#include <printk.h>

int SUM_Main_Update(KEY *params); 

int SUM_Main_Update(KEY *params) 
{
  EXEC SQL TYPE uint64_t IS unsigned long long;

EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR online_status[5];
  VARCHAR arch_status[5];
  VARCHAR offsite_ack[5];
  char history_comment[80];
  int storage_group;
  int storage_set;
  int safe_id;
  double bytes;
  uint64_t ds_index;
  uint64_t create_sumid;
  char *username;
  char *ccomment;
  char wd[80];
  char *cwd = wd;
  char *dsname;
  VARCHAR l_date[32];
  int mode;
  int  apstatus;
  int  archsub;
  int touch;
  char *effective_date;
EXEC SQL END DECLARE SECTION;
  char dsnamestr[128];
  
EXEC SQL INCLUDE sqlca;

   create_sumid = getkey_uint64(params, "uid");
   safe_id = 0;			/* !!TBD check use of this */

   strcpy(wd, GETKEY_str(params,"wd_0"));
   if(!strcmp(wd, "")) return(1);
   if(!findkey(params, "history_comment")) { strcpy(history_comment, " "); }
   else {
     ccomment = GETKEY_str(params, "history_comment");
     if(strlen(ccomment) > 79) { 
       strncpy(history_comment, ccomment, 79);
       history_comment[79] = '\0';
     }
     else { strcpy(history_comment, ccomment); }
   }
   ccomment = history_comment;
   ds_index = getkey_uint64(params, "dsix_0");

   strcpy(online_status.arr, "Y");
   online_status.len = strlen(online_status.arr);
   strcpy(arch_status.arr, "N");
   arch_status.len = strlen(arch_status.arr);
   strcpy(offsite_ack.arr, "N");
   offsite_ack.len = strlen(offsite_ack.arr);
   dsname = getkey_str(params, "dsname");
   if(!dsname) { strcpy(dsnamestr,  "<none>"); }
   else { 
     strcpy(dsnamestr, dsname);
     free(dsname);
   }
   dsname = dsnamestr;
   storage_group = getkey_int(params, "group");
   storage_set = getkey_int(params, "storage_set");
   bytes = getkey_double(params, "bytes");
   username = getkey_str(params, "username");
   mode = getkey_int(params, "mode");
   if (SUMS_TAPE_AVAILABLE) apstatus = DAAP;
   else apstatus = DADP; 
   if(mode & ARCH) {
     archsub = DAADP;
   }
   if(mode & TEMP) {
     archsub = DAAEDDP;
   }
   if(mode & PERM) {
     archsub = DAAPERM;
   }
   if(findkey(params, "tdays")) touch = abs(getkey_int(params, "tdays"));
   else touch = 2;
   effective_date = (char *)get_effdate(touch);
   sprintf(l_date.arr, "%s", get_datetime());
   l_date.len = strlen(l_date.arr);

   EXEC SQL WHENEVER SQLERROR GOTO sqlerror;

   EXEC SQL 
      INSERT INTO SUM_MAIN 
         (ONLINE_LOC, 
          ONLINE_STATUS, 
          ARCHIVE_STATUS, 
          OFFSITE_ACK, 
	  DS_INDEX,
	  CREATE_SUMID,
          HISTORY_COMMENT,
	  OWNING_SERIES,
          STORAGE_GROUP,
          STORAGE_SET,
	  BYTES,
	  CREAT_DATE,
	  ACCESS_DATE,
	  USERNAME
	 ) 
	VALUES
         (:cwd, 
          :online_status,
          :arch_status, 
          :offsite_ack, 
	  :ds_index,
	  :create_sumid,
	  :ccomment, 
	  :dsname,
          :storage_group,
          :storage_set,
	  :bytes,
          :l_date,
          :l_date,
	  :username
	 );

   if(NC_PaUpdate(cwd, create_sumid, bytes, apstatus, archsub, effective_date, 
       storage_group, safe_id, ds_index, 1, 0)) {
     EXEC SQL ROLLBACK WORK;
     return(1);
   }
   free(effective_date);
   free(username);
   EXEC SQL COMMIT WORK;
   return(0);

sqlerror:
    printk("Error in SUM_Main_Update() \n");
    printk("% .70s \n", sqlca.sqlerrm.sqlerrmc);
    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL ROLLBACK WORK;
    return(1);
}
