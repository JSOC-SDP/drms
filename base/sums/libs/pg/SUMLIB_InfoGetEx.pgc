/* SUMLIB_InfoGetEx.pgc
 * Returns in the results keylist info on the storage units for the 
 * given ds_index values. 
 * The keywords in the input KEY * are like so:
 *   uid    = unique id from a SUM_open() call for this session
 *   reqcnt = number of ds_index values being requested
 *   dsix_0 = first ds_index value 
 *   dsix_1 = second ds_index value 
 *   [etc.]
 * Returns 0 on success, else error code.
 * Does the query of all the ds_index values in a single SQL call.
 * This is faster than doing a call for each ds_index.
 */
#include <SUM.h>
#include <sum_rpc.h>
#include <soi_error.h>
#include <printk.h>


static int n_off, n_total;	/* counts since dsds_svc started */
static int c_off, c_total;	/* counts for last 100 ds */
static char dsix_name[128];
static char testname[256];

int SUMLIB_InfoGetEx(KEY *params, KEY **results);

int SUMLIB_InfoGetEx(KEY *params, KEY **results)
{
  EXEC SQL TYPE uint64_t IS unsigned long long;

EXEC SQL BEGIN DECLARE SECTION;
  char stmt[8192];
  uint64_t uid;
  uint64_t ds_index;
  uint64_t ds_index_arr[MAXSUMREQCNT];
  int  touch;
  int  daro = DARO;

    int pa_status;
    int pa_substatus;
    VARCHAR effective_date[20];

    VARCHAR online_loc[81];
    VARCHAR online_status[5];
    VARCHAR archive_status[5];
    VARCHAR offsite_ack[5];
    VARCHAR history_comment[81];
    VARCHAR owning_series[81];
    int storage_group;
    double bytes;
    uint64_t create_sumid;
    VARCHAR creat_date[32];
    VARCHAR username[11];
    VARCHAR arch_tape[21];
    int arch_tape_fn;
    VARCHAR arch_tape_date[32];
    VARCHAR safe_tape[21];
    int safe_tape_fn;
    VARCHAR safe_tape_date[32];
EXEC SQL END DECLARE SECTION;
   int i, reqcnt;

    uid = getkey_uint64(params, "uid");
    reqcnt = getkey_int(params, "reqcnt");
  	 
     EXEC SQL WHENEVER SQLERROR GOTO sqlerror;
     EXEC SQL WHENEVER NOT FOUND GOTO noerror;
    //Make the query statement.
    for(i=0; i < reqcnt ; i++) {
      sprintf(dsix_name, "dsix_%d", i);
      if(!findkey(params, dsix_name)) {
        printk("Bad keylist given to DS_DataRequest()\n");
        return(DS_DATA_REQ);
      }
      ds_index = getkey_uint64(params, dsix_name);


 EXEC SQL SELECT online_loc, online_status, archive_status, offsite_ack,
 history_comment, owning_series, storage_group, bytes, create_sumid, creat_date, username,
 coalesce(arch_tape,'N/A'), coalesce(arch_tape_fn,0),
 coalesce(arch_tape_date,'1958-01-01 00:00:00'),
 coalesce(safe_tape,'N/A'), coalesce(safe_tape_fn,0),
 coalesce(safe_tape_date,'1958-01-01 00:00:00')
 INTO :online_loc, :online_status, :archive_status, :offsite_ack,
 :history_comment, :owning_series, :storage_group, :bytes, :create_sumid, :creat_date,
 :username, :arch_tape, :arch_tape_fn, :arch_tape_date, :safe_tape,
 :safe_tape_fn, :safe_tape_date
 FROM SUM_MAIN WHERE DS_INDEX = :ds_index;

        sprintf(dsix_name, "online_loc_%d", i);
        sprintf(testname, "online_loc_%d", i);
    	setkey_str(results, dsix_name, online_loc.arr);
        sprintf(dsix_name, "online_status_%d", i);
        setkey_str(results, dsix_name, online_status.arr);
        sprintf(dsix_name, "archive_status_%d", i);
    	setkey_str(results, dsix_name, archive_status.arr); 
        sprintf(dsix_name, "offsite_ack_%d", i);
    	setkey_str(results, dsix_name, offsite_ack.arr); 
        sprintf(dsix_name, "history_comment_%d", i);
    	setkey_str(results, dsix_name, history_comment.arr); 
        sprintf(dsix_name, "owning_series_%d", i);
    	setkey_str(results, dsix_name, owning_series.arr); 
        sprintf(dsix_name, "storage_group_%d", i);
        setkey_int(results, dsix_name, storage_group);
        sprintf(dsix_name, "bytes_%d", i);
 	setkey_double(results, dsix_name, bytes);
        sprintf(dsix_name, "creat_date_%d", i);
    	setkey_str(results, dsix_name, creat_date.arr); 
        sprintf(dsix_name, "username_%d", i);
    	setkey_str(results, dsix_name, username.arr); 
        sprintf(dsix_name, "arch_tape_%d", i);
    	setkey_str(results, dsix_name, arch_tape.arr); 
        sprintf(dsix_name, "arch_tape_fn_%d", i);
        setkey_int(results, dsix_name, arch_tape_fn);
        sprintf(dsix_name, "arch_tape_date_%d", i);
    	setkey_str(results, dsix_name, arch_tape_date.arr); 
        sprintf(dsix_name, "safe_tape_%d", i);
    	setkey_str(results, dsix_name, safe_tape.arr); 
        sprintf(dsix_name, "safe_tape_fn_%d", i);
        setkey_int(results, dsix_name, safe_tape_fn);
        sprintf(dsix_name, "safe_tape_date_%d", i);
    	setkey_str(results, dsix_name, safe_tape_date.arr); 
        sprintf(dsix_name, "ds_index_%d", i);
        setkey_uint64(results, dsix_name, ds_index);

      //now get values in sum_partn_alloc
     EXEC SQL SELECT status, archive_substatus, effective_date
     INTO :pa_status, :pa_substatus, :effective_date
     FROM SUM_PARTN_ALLOC WHERE DS_INDEX = :ds_index and STATUS != 8;
        sprintf(dsix_name, "pa_status_%d", i);
        setkey_int(results, dsix_name, pa_status);
        sprintf(dsix_name, "pa_substatus_%d", i);
        setkey_int(results, dsix_name, pa_substatus);
        sprintf(dsix_name, "effective_date_%d", i);
        setkey_str(results, dsix_name, effective_date.arr);
        continue;
    noerror:
        sprintf(dsix_name, "pa_status_%d", i);
        setkey_int(results, dsix_name, 0);
        sprintf(dsix_name, "pa_substatus_%d", i);
        setkey_int(results, dsix_name, 0);
        sprintf(dsix_name, "effective_date_%d", i);
        setkey_str(results, dsix_name, "N/A");
        continue;
sqlerror:
        printk("sqlerror for i=%d ds_index = %u\n", i, ds_index);
    }
        setkey_int(results, "reqcnt", reqcnt);
    	EXEC SQL COMMIT WORK;
	return NO_ERROR;
}
