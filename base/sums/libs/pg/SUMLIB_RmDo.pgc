/* SUMLIB_RmDo.pc
 * Called by sum_rm to find expired dirs and remove them.
 */
#include <SUM.h>
#include <sum_rpc.h>
#include <soi_error.h>
#include <printk.h>

EXEC SQL TYPE uint64_t IS unsigned long long;

int DS_RmDo(double *bytesdel)
{

EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR l_wd[80];
  VARCHAR l_eff_date[20];
  uint64_t l_sumid;
  uint64_t ds_index;
  int l_archsub;
  double l_bytes;
EXEC SQL END DECLARE SECTION;
  double bytesdeleted, rmbytes;
  int i, j;

  typedef struct palloc_cursor {
    char p_wd[80];
    uint64_t p_sumid;
    double p_bytes;
    char p_effdate[20];
    uint64_t p_ds_index;
    int p_archsub;
  } PALLOC_CURSOR;
  PALLOC_CURSOR pcursor[800];

  printk("DS_RmDo\n");  
  bytesdeleted = 0.0;

  EXEC SQL WHENEVER SQLERROR GOTO sqlerror;

  EXEC SQL DECLARE palloc CURSOR FOR
	SELECT WD, SUMID, BYTES, EFFECTIVE_DATE,
	DS_INDEX, ARCHIVE_SUBSTATUS FROM SUM_PARTN_ALLOC
	where STATUS=2 order by effective_date limit 800;

  EXEC SQL OPEN palloc;

  EXEC SQL WHENEVER NOT FOUND GOTO end_fetch; 
	
/* Warn about SUMDC code commented out below */
printk("WARN: tmp noop of offsite_ack check\n"); /* !!!TEMP */

  for(i=0; ; i++ ){
    EXEC SQL FETCH palloc INTO :l_wd, :l_sumid, :l_bytes, :l_eff_date, :ds_index, :l_archsub;
    /* must save results as can't put other sql calls in this loop */
    strcpy(pcursor[i].p_wd, l_wd.arr);
    pcursor[i].p_sumid = l_sumid;
    pcursor[i].p_bytes = l_bytes;
    strcpy(pcursor[i].p_effdate, l_eff_date.arr);
    pcursor[i].p_ds_index = ds_index;
    pcursor[i].p_archsub = l_archsub;
  }

end_fetch:
    EXEC SQL CLOSE palloc;
    EXEC SQL WHENEVER NOT FOUND GOTO end_fetch2;
    for(j=0; j < i; j++) {
#ifdef SUMDC
      /* only rm those with Offsite_Ack, and Safe_Tape */

/* !!!TEMP don't do this for testing with DDS */
//      ds_index = pcursor[j].p_ds_index;
//      EXEC SQL  SELECT DS_INDEX into :ds_index from sum_main
//      WHERE DS_INDEX = :ds_index AND
//      OFFSITE_ACK = 'Y' AND SAFE_TAPE IS NOT NULL;
//
#endif
      if(DS_RmNow(pcursor[j].p_wd, pcursor[j].p_sumid, pcursor[j].p_bytes, 
		pcursor[j].p_effdate, 
		pcursor[j].p_ds_index, pcursor[j].p_archsub, &rmbytes)) {
        EXEC SQL ROLLBACK WORK;
        return DS_DATA_QRY;
      }
      bytesdeleted += rmbytes;     /* add what we deleted so far */
end_fetch2:
      continue;
    }
    *bytesdel = bytesdeleted;
    EXEC SQL COMMIT;
    return NO_ERROR;
	
sqlerror:
    printk("Error in DS_RmDo\n");
    printk("% .70s \n", sqlca.sqlerrm.sqlerrmc);
    EXEC SQL ROLLBACK WORK;
    return DS_DATA_QRY;
}

int DS_RmNow(char *wd, uint64_t sumid, double bytes, char *effdate,
		uint64_t ds_index, int archsub, double *rmbytes) {
EXEC SQL BEGIN DECLARE SECTION;
  int l_count;
  uint64_t l_ds_index;
EXEC SQL END DECLARE SECTION;
  uint64_t eff_date, today_date;
  char rwd[80];
  char *rootdir, *cptr, *cptr1;

  EXEC SQL WHENEVER SQLERROR GOTO sqlrmerror;
  EXEC SQL WHENEVER NOT FOUND GOTO sqlrmerror; 

    today_date = (uint64_t)atol(get_effdate(0));
    EXEC SQL SELECT count(*) INTO :l_count from SUM_PARTN_ALLOC
        where DS_INDEX = :l_ds_index and status = 8;
    /* !!!TBD lock the table before determine if it's DARO */
    if(l_count) {
       printk("%s is open DARO\n", wd);
       *rmbytes = 0.0;
       EXEC SQL COMMIT;
       return(0);		/* skip this dir opend for read */
    }
    eff_date = (uint64_t)atol(effdate);

//printk("DS_RmNow() wd=%s eff_date=%lu today_date=%lu\n", wd, eff_date, today_date); //!!!TEMP

    rootdir = strcpy(rwd, wd);
    //contin with del if garbage date > year 30000
    if(eff_date < 3000000000000) { //yyyymmddhhss
      if(eff_date > today_date) {
        *rmbytes = 0.0;
        EXEC SQL COMMIT;
        return(0);
      }
    }
    /* remove del pend entry from sum_partn_alloc tbl */
    if(NC_PaUpdate
        (wd, sumid, bytes,DADP,0,0,0,0,0,0,1))
    {
      printk("Err: NC_PaUpdate(%s,%ld,%e,DADP,0,0,0, ...)to rm from dp list\n", 
		wd,sumid,bytes);
      printk("  ??This is how we got the info in the first place!\n");
    }
    if(!(cptr = strstr(rootdir+1, "/D"))) {
      printk("The wd=%s doesn't have a /.../Dxxx term!\n",rootdir);
      *rmbytes = 0.0;
      EXEC SQL COMMIT;
      return(0);
    }
    if((cptr1 = strstr(cptr+1, "/"))) {
      *cptr1 = (char)NULL;		/* make like /SUM1/D1234 */
    }
    printk("Removing %s\n", wd);
    if(ds_index != 0) {         /* Don't take offline if 0*/
    if(SUM_StatOffline(ds_index)) {
      printk("Err: SUM_StatOffline(%ld, ...)\n", ds_index);
    }
    }
    if(archsub == DAAEDDP) {   /* a temporary dataset */
      printk("Removing sum_main for ds_index = %ld\n", ds_index);
      if(DS_SumMainDelete(ds_index)) {
        printk("**Err: DS_SumMainDelete(%ld)\n", ds_index);
      }
    }
    if(rmdirs(wd, rootdir)) {
      printk("Cannot rm %s\n", wd);
    }
    *rmbytes = bytes;
    EXEC SQL COMMIT;
    return(0);

sqlrmerror:
    printk("Error in DS_RmNow\n");
    printk("% .70s \n", sqlca.sqlerrm.sqlerrmc);
    EXEC SQL ROLLBACK WORK;
    return DS_DATA_QRY;
}
