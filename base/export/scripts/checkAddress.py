#!/usr/bin/env python3

# The arguments to this script are parsed by cgi.FieldStorage(), which knows how to parse
# both HTTP GET and POST requests. A nice feature is that we can test the script as it runs in a CGI context
# by simply running on the command line with a single argument that is equivalent to an HTTP GET parameter string
# (e.g., address=gimli@mithril.com&addresstab=jsoc.export_addresses&domaintab=jsoc.export_addressdomains).

# Parameters:
#   address (required) - The email address to check or register.
#   addresstab (required) - The database table containing all registered (or registration-pending) email addresses.
#   domaintab (required) - The database table containing all email domains.
#   dbuser (optional) - The database account to be used when connecting to the database. The default is the value of the WEB_DBUSER parameter in DRMSParams.
#   checkonly (optional) - If set to 1, then no attept is made to register an unregistered email. In this case, if no error occurs then the possible return status codes are RV_REGISTEREDADDRESS, RV_REGISTRATIONPENDING, or RV_UNREGISTEREDADDRESS. The default is False (unknown addresses are registered).

import sys
import os
import pwd
import re
import uuid
from datetime import datetime
from urllib.parse import unquote
import smtplib
import cgi
import json
import psycopg2
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../../include'))
from drmsparams import DRMSParams

# Return values
RV_ERROR = -1
RV_ERROR_ARGS = -2
RV_ERROR_MAIL = -3
RV_ERROR_PARAMS = -4
RV_ERROR_DBCMD = -5
RV_ERROR_DBCONNECT = -6
RV_ERROR_DUPECONFIRMATION = -7
RV_REGISTRATIONINITIATED = 1
RV_REGISTEREDADDRESS = 2
RV_REGISTRATIONPENDING = 3
RV_UNREGISTEREDADDRESS = 4

def SendMail(address, timeout, confirmation):
    subject = 'CONFIRM EXPORT ADDRESS'
    fromAddr = 'jsoc@solarpost.stanford.edu'
    toAddrs = [ address ]
    bccAddrs = [ 'art.amezcua@stanford.edu' ]
    msg = 'From: ' + fromAddr + '\nTo: ' + ','.join(toAddrs) + '\nSubject: ' + subject + '\nThis message was automatically generated by the JSOC export system at Stanford.\n\nYou have requested that data be exported from the JSOC. To do so, you must register your email address with the export system. To complete the registration process, please reply to this message within ' + timeout + ' minutes. Please do not modify the body of this message when replying. The server will extract the embedded confirmation code to verify that the provided email address is valid. You will receive another email message notifying you of the disposition of your registration.'
    msg += '\n[' + str(confirmation) + ']'

    try:
        server = smtplib.SMTP('solarpost.stanford.edu')
        server.sendmail(fromAddr, toAddrs + bccAddrs, msg)
        server.quit()
    except Exception as exc:
        # If any exception happened, then the email message was not received.
        raise Exception('emailBadrecipient', 'Unable to send email message to address to confirm address.', RV_ERROR_MAIL)


if __name__ == "__main__":
    msg = None
    rv = RV_ERROR
    user_id = None
    rootObj = {}

    try:
        optD = {}

        # Should be invoked as an HTTP POST. If this script is invoked via HTTP POST, then FieldStorage() will consume the arguments passed
        # via STDIN, and they will no longer be available to any program called by this script.

        # I think I finally figured it out. cgi.FieldStorage() uses the REQUEST_METHOD environment variable to determine if the
        # arguments are from STDIN or in QUERY_STRING (if it exists) / sys.argv[1]. If REQUEST_METHOD is not set, then it gets
        # the args from QUERY_STRING/sys.argv[1]. If REQUEST_METHOD is set, then it uses stdin.
        arguments = cgi.FieldStorage()

        optD['checkonly'] = False

        if arguments:
            for key in arguments.keys():
                val = arguments.getvalue(key)

                if key in ('address'):
                    optD['address'] = unquote(val)
                elif key in ('name'):
                    optD['name'] = unquote(val)
                elif key in ('snail'):
                    optD['snail'] = unquote(val)
                elif key in ('db_name'):
                    optD['db_name'] = val
                elif key in ('db_user'):
                    optD['db_user'] = val
                elif key in ('db_host'):
                    optD['db_host'] = val
                elif key in ('db_port'):
                    optD['db_port'] = val
                elif key in ('checkonly'):
                    if int(val) == 1:
                        optD['checkonly'] = True
                # Do not worry about extraneous arguments. I had to add a 'sleep' argument to the shell wrapper, but I do not
                # know how to strip arguments in shell.

        # Ensure required arguments are present.
        if 'address' not in optD:
            raise Exception('caArgs', "Missing required argument 'address'.", RV_ERROR_ARGS)

        if 'name' not in optD:
            optD['name'] = 'NULL';

        if 'snail' not in optD:
            optD['snail'] = 'NULL';

        # Do a quick validation on the email address.
        regExp = re.compile(r'\s*[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6}')
        matchObj = regExp.match(optD['address'])
        if matchObj is None:
            raise Exception('caArgs', 'Not a valid email address.', RV_ERROR_ARGS)

        drms_params = DRMSParams()
        if drms_params is None:
            raise Exception('drmsParams', 'unable to locate DRMS parameters file (drmsparams.py)', RV_ERROR_PARAMS)

        # override defaults if the user has provided overrides
        if 'db_name' in optD:
            drms_params.DBNAME = optD['db_name']

        if 'db_user' in optD:
            drms_params.WEB_DBUSER = optD['dbuser']

        if 'db_host' in optD:
            drms_params.SERVER = optD['db_host']

        if 'db_port' in optD:
            drms_params.DRMSPGPORT = optD['db_port']

        try:
            with psycopg2.connect(database=drms_params.DBNAME, user=drms_params.WEB_DBUSER, host=drms_params.SERVER, port=drms_params.DRMSPGPORT) as conn:
                with conn.cursor() as cursor:
                    # registered domain names are always lower case - the comparison should be case-insensitive
                    cmd = 'SELECT confirmation FROM ' + drms_params.EXPORT_ADDRESS_INFO_FN + "('" + optD['address'] + "')"

                    try:
                        cursor.execute(cmd)
                        rows = cursor.fetchall()
                        if len(rows) > 1:
                            raise Exception('dbCorruption', 'unexpected number of rows returned: ' + cmd, RV_ERROR_DBCMD)
                    except psycopg2.Error as exc:
                        # Handle database-command errors.
                        raise Exception('dbCmd', exc.diag.message_primary, RV_ERROR_DBCMD)

                    if len(rows) == 0:
                        # email address is not in our database
                        if optD['checkonly']:
                            # do not initiate registration
                            rv = RV_UNREGISTEREDADDRESS
                            msg = 'email address has been neither validated nor registered'
                        else:
                            # register it (insert row into addresses_tab with a confirmation code)
                            confirmation = uuid.uuid4()

                            # ensure confirmation does not already exist in addresses_tab
                            cmd = 'SELECT confirmation FROM ' + drms_params.EXPORT_ADDRESS_INFO_FN + '()'  + " WHERE confirmation ='" + str(confirmation) + "'"

                            try:
                                cursor.execute(cmd)
                                rows = cursor.fetchall()
                                if len(rows) > 0:
                                    raise Exception('dupeConfirmation', 'cannot insert row into address table; confirmation ' + str(confirmation) + ' already exists', RV_ERROR_DUPECONFIRMATION)
                            except psycopg2.Error as exc:
                                # Handle database-command errors.
                                raise Exception('dbCmd', exc.diag.message_primary, RV_ERROR_DBCMD)

                            # insert into the addresses table (and domains table if need be)
                            cmd = 'SELECT * FROM ' + drms_params.EXPORT_ADDRESS_INFO_INSERT_FN + "('" + optD['address'] + "', '" + str(confirmation) + "')"
                            try:
                                cursor.execute(cmd)
                            except psycopg2.Error as exc:
                                # Handle database-command errors.
                                raise Exception('dbCmd', exc.diag.message_primary, RV_ERROR_DBCMD)

                            # we have to also insert into the export user table since we have that information now, not after the user has replied to the registration email
                            # (which is processed by registerAddress.py); if a failure happens anywhere along the way, we need to delete the entry from the export user table
                            cmd = 'SELECT id FROM ' + drms_params.EXPORT_USER_INFO_INSERT_FN + "('" + optD['address'] + "', '" + optD['name'] + "', '" + optD['snail'] + "')"
                            try:
                                cursor.execute(cmd)
                                rows = cursor.fetchall()
                            except psycopg2.Error as exc:
                                # Handle database-command errors.
                                raise Exception('dbCmd', exc.diag.message_primary, RV_ERROR_DBCMD)

                            user_id = rows[0][0]

                            # send an email message out with a new confirmation code
                            SendMail(optD['address'], drms_params.REGEMAIL_TIMEOUT, confirmation)

                            rv = RV_REGISTRATIONINITIATED
                            msg = 'Your email address has not been registered for use with the export system - starting registration process. You will receive an email address from user jsoc. Please reply to this email message within ' + str(drms_params.REGEMAIL_TIMEOUT) + ' minutes without modifying the body.'
                    else:
                        # email address is in our database; check to see if registration is pending
                        confirmation = rows[0][0]

                        if confirmation is None or len(confirmation) == 0:
                            # Email address in our database is registered.
                            rv = RV_REGISTEREDADDRESS
                            msg = 'Email address is valid and registered.'

                            # get requestor ID also
                            cmd = 'SELECT id FROM ' + drms_params.EXPORT_USER_INFO_TABLE + " WHERE lower(address) = lower('" + optD['address'] + "')"
                            try:
                                cursor.execute(cmd)
                                rows = cursor.fetchall()
                            except psycopg2.Error as exc:
                                # handle database-command errors
                                raise Exception('dbCmd', exc.diag.message_primary, RV_ERROR_DBCMD)

                            user_id = rows[0][0]
                        else:
                            # We are in the process of registering this address already.
                            rv = RV_REGISTRATIONPENDING
                            msg = 'Email-address registration is pending. Please wait and try again later.'

                    if user_id is None:
                        user_id = -1
        except psycopg2.DatabaseError as exc:
            # Closes the cursor and connection

            # Man, there is no way to get an error message from any exception object that will provide any information why
            # the connection failed.
            raise Exception('dbConnect', 'unable to connect to the database', RV_ERROR_DBCONNECT)
    except Exception as exc:
        if len(exc.args) != 3:
            raise # Re-raise

        etype = exc.args[0]

        if etype == 'emailBadrecipient' or etype == 'caArgs' or etype == 'drmsParams' or etype == 'dbCorruption' or etype == 'dbCmd' or etype == 'dbConnect' or etype == 'dupeConfirmation':
            msg = exc.args[1]
            rv = exc.args[2]

            if msg:
                # print to web error_log
                print('fatal ERROR in checkAddress.py: ' + msg, file=sys.stderr)
        else:
            raise # Re-raise

    if rv != RV_REGISTRATIONINITIATED and rv != RV_REGISTEREDADDRESS and rv != RV_REGISTRATIONPENDING:
        if msg is None:
            msg = 'Unknown error'

    rootObj['status'] = rv
    rootObj['msg'] = msg
    rootObj['user_id'] = user_id

    # Do not print application/json here. This script may be called outside of a CGI context.
    print(json.dumps(rootObj))

    # Always return 0. If there was an error, an error code (the 'status' property) and message (the 'statusMsg' property) goes in the returned HTML.
    sys.exit(0)
