#!/usr/bin/env python3

import sys
import os
import fileinput
import email
import re
import smtplib
from datetime import datetime, timedelta
import psycopg2
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../../../include'))
from drmsparams import DRMSParams

# Return values
RV_ERROR_NONE = 0
RV_ERROR = -1
RV_ERROR_PARAMS = -2
RV_ERROR_DBCMD = -3
RV_ERROR_DBCONNECT = -4
RV_ERROR_TIMEOUT = -5
RV_ERROR_CONFIRMATION = -6
RV_ERROR_MESSAGE = -7
RV_ERROR_ADDRESS = -8
RV_ERROR_BODY = -9
RV_ERROR_MAIL = -10

# By default, procmail prints these lines to the procmail log:
# From nour4soccer@gmail.com  Fri Feb 10 08:19:23 2017
#  Subject: Re: CONFIRM EXPORT ADDRESS
#   Folder: /home/jsoc/cvs/Development/JSOC/base/export/scripts/register     5390
#
# To disable this default behavior, add the LOGABSTRACT=no variable to .procmailrc.
# Anything printed by this script will appear AFTER these three lines.

# Print stdin
# import fileinput
# fobj = open('/home/jsoc/thefile2.txt', 'a')
# for line in fileinput.input():
#    print(line, file=fobj)

# another way to test:
# 1. place email body into eml_file.txt (use email client to download a full .eml file)
# 2. edit eml_file.txt, replacing all jsoc@sun.stanford.edu with the email address being registered
# 2. $ cat eml_file.txt | /home/jsoc/anaconda3/bin/python3 ~arta/jsoctrees/JSOC/base/export/scripts/registerAddress.py

def getDRMSParam(drmsParams, param):
    rv = drmsParams.get(param)
    if not rv:
        raise Exception('drmsParams', 'DRMS parameter ' + param + ' is not defined.', RV_ERROR_PARAMS)

    return rv

def SendMailSuccess(address):
    subject = 'EXPORT ADDRESS REGISTERED'
    fromAddr = 'jsoc@solarpost.stanford.edu'
    toAddrs = [ address ]
    msg = 'From: jsoc@solarpost.stanford.edu\nTo: ' + ','.join(toAddrs) + '\nSubject: ' + subject + '\nThis message was automatically generated by the JSOC export system at Stanford.\n\nYour email address has been successfully registered.'

    try:
        server = smtplib.SMTP('solarpost.stanford.edu')
        server.sendmail(fromAddr, toAddrs, msg)
        server.quit()
    except Exception as exc:
        # If any exception happened, then the email message was not received.
        raise Exception('emailBadrecipient', 'Unable to send email message to address to confirm address.', RV_ERROR_MAIL)

def SendMailFailure(address, msg):
    subject = 'FAILURE REGISTERING EXPORT ADDRESS'
    fromAddr = 'jsoc@solarpost.stanford.edu'
    toAddrs = [ address ]
    msg = 'From: jsoc@solarpost.stanford.edu\nTo: ' + ','.join(toAddrs) + '\nSubject: ' + subject + '\nThis message was automatically generated by the JSOC export system at Stanford.\n\nSorry, we were unable to register your email address. ' + msg

    try:
        server = smtplib.SMTP('solarpost.stanford.edu')
        server.sendmail(fromAddr, toAddrs, msg)
        server.quit()
    except Exception as exc:
        # If any exception happened, then the email message was not received.
        raise Exception('emailBadrecipient', 'Unable to send email message to address to confirm address.', RV_ERROR_MAIL)

if __name__ == "__main__":
    rv = RV_ERROR_NONE

    try:
        actualMessage = None # the message containing the email body
        addressField = None
        address = None
        body = None
        confirmation = None

        textIn = sys.stdin.read() # text string (sys.stdin is a str of chars; each char in the text string is a Unicode code point (an integer between 0 and 0x10FFFF))

        # If there are empty lines, or lines with only whitespace, in the incoming
        # message, then message_from_string() considers every thing after the first empty line the body of the message.
        strippedTextIn = '\n'.join([ line for line in textIn.split('\n') if line.strip() != '' ])

        message = email.message_from_string(strippedTextIn) # never fails, even for an invalid email message

        if message.is_multipart():
            # for multi-part messages, the sender's address is in the top-level message, but the body is in one of the
            # 'parts'; we are assuming it is in the first text/plain part
            addressField = message.get('from')

            if not addressField:
                raise Exception('raAddress', "Sender's email address not found in email reply header.", RV_ERROR_ADDRESS)

            for amessage in message.get_payload():
                type = amessage.get_content_type()
                disposition = amessage.get_content_disposition()

                if type == 'text/plain' and not disposition == 'attachment':
                    actualMessage = amessage
                    break
        else:
            addressField = message.get('from')
            if not addressField:
                raise Exception('raAddress', "Sender's email address not found in email reply header.", RV_ERROR_ADDRESS)

            actualMessage = message

        if actualMessage == None:
            raise Exception('raMessage', 'Invalid email message.', RV_ERROR_MESSAGE)

        parsedAddressField = email.utils.parseaddr(addressField)
        if len(parsedAddressField[1]) > 0:
            address = parsedAddressField[1]

        bodyEncoded = actualMessage.get_payload(decode=True) # decodes base64 and quoted-printable only; most likely the resulting body is non-ascii (binary) data (although it could be ascii)
        if not bodyEncoded:
            raise Exception('raBody', 'Email message has no body.', RV_ERROR_BODY)

        charset = actualMessage.get_content_charset()
        if not charset:
            charset = 'utf8'
        body = bodyEncoded.decode(charset) # if bodyEncoded is ascii data, utf8 will work; if bodyEncoded is non-ascii (binary) data, then get_content_charset() should indicate the encoding; if this is binary data, and there is no charset provided, try utf8

        # stderr goes to procmail log
        print('** message address: ' + address, file=sys.stderr)
        print('** message body: ' + body, file=sys.stderr)

        regExpS = re.compile(r'\[([0-9A-Fa-f]{8}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{4}\-[0-9A-Fa-f]{12})\]')
        matchObj = regExpS.search(body)
        if matchObj:
            confirmation = matchObj.group(1)

        if confirmation:
            # stderr goes to procmail log
            print('** confirmation code: ' + confirmation, file=sys.stderr)
        else:
            raise Exception('raConfirmation', 'Confirmation code not found in email reply from address ' + address + '.', RV_ERROR_CONFIRMATION)

        drms_params = DRMSParams()
        if drms_params is None:
            raise Exception('drmsParams', 'Unable to locate DRMS parameters file (drmsparams.py).', RV_ERROR_PARAMS)

        try:
            with psycopg2.connect(database=drms_params.DBNAME, user=drms_params.EXPORT_PRODUCTION_DB_USER, host=drms_params.SERVER, port=drms_params.DRMSPGPORT) as conn:
                with conn.cursor() as cursor:
                    # find row in addresses table by searching for confirmation
                    cmd = 'SELECT address, confirmation, starttime FROM ' + drms_params.EXPORT_ADDRESS_INFO_FN + "() WHERE confirmation = '" + confirmation + "'"
                    try:
                        cursor.execute(cmd)
                        rows = cursor.fetchall()
                        if len(rows) == 0:
                            raise Exception('raConfirmation', 'Confirmation code ' + confirmation + ' not recognized.', RV_ERROR_CONFIRMATION)
                        if len(rows) != 1:
                            raise Exception('dbCorruption', 'Unexpected number of rows (' + str(len(rows)) + ') returned: ' + cmd + '.', RV_ERROR_DBCMD)
                    except psycopg2.Error as exc:
                        # Handle database-command errors.
                        raise Exception('dbCmd', exc.diag.message_primary, RV_ERROR_DBCMD)

                    address_db = rows[0][0] # cannot be null (db constraint)
                    confirmation_db = rows[0][1] # cannot be null, otherwise no rows would have been returned
                    starttime_db = rows[0][2] # cannot be null (db constraint)

                    print('** registering address: ' + address_db + ' (' + confirmation_db + ')', file=sys.stderr)

                    # reject if the confirmation code has expired
                    if datetime.now(starttime_db.tzinfo) > starttime_db + timedelta(minutes=int(drms_params.REGEMAIL_TIMEOUT)):
                        raise Exception('raTimeout', 'The confirmation code, ' + confirmation + ', for address ' + address_db + ' has expired.', RV_ERROR_TIMEOUT)

                    # remove confirmation code from address's record in jsoc.export_addresses; this is how we signify that the address has
                    # been successfully registered
                    cmd = 'SELECT * FROM ' + drms_params.EXPORT_ADDRESS_INFO_UPDATE_FN + "('" + address_db + "', '', NULL)"

                    try:
                        cursor.execute(cmd)
                    except psycopg2.Error as exc:
                        # Handle database-command errors.
                        raise Exception('dbCmd', exc.diag.message_primary + ": " + cmd, RV_ERROR_DBCMD)

                    # registration was successful - keep the entry in the jsoc.export_user_info table that was created by checkAddress.py

                    SendMailSuccess(address)
                    print('** succesful registration: ' + address + ' (' + confirmation + ')', file=sys.stderr)

        except psycopg2.DatabaseError as exc:
            # Closes the cursor and connection.

            # Man, there is no way to get an error message from any exception object that will provide any information why
            # the connection failed.
            raise Exception('dbConnect', 'Unable to connect to the database.', RV_ERROR_DBCONNECT)

    except Exception as exc:
        if len(exc.args) != 3:
            if address:
                SendMailFailure(address, 'Please visit the export page and register your address again.')
            import traceback
            print('Unhandled exception: ' + traceback.format_exc(8) + '.', file=sys.stderr)
            raise # Re-raise

        etype = exc.args[0]

        if etype == 'drmsParams' or etype == 'dbCorruption' or etype == 'dbCmd' or etype == 'dbConnect' or etype == 'raConfirmation' or etype == 'emailBadrecipient' or etype == 'raTimeout' or etype == 'raMessage' or etype == 'raAddress' or etype == 'raBody':
            msg = exc.args[1]
            rv = exc.args[2]

            if address:
                if msg and len(msg) > 0:
                    mailMsg = msg + '\nPlease visit the export page and register your address again.'
                SendMailFailure(address, mailMsg)

            # The procmail log captures stderr only.
            if msg and len(msg) > 0:
                print(msg, file=sys.stderr)

            with psycopg2.connect(database=drms_params.DBNAME, user=drms_params.EXPORT_PRODUCTION_DB_USER, host=drms_params.SERVER, port=drms_params.DRMSPGPORT) as conn:
                with conn.cursor() as cursor:
                    if etype == 'raTimeout':
                        # remove row from address table
                        cmd = 'SELECT * FROM ' + drms_params.EXPORT_ADDRESS_INFO_DELETE_FN + "('" + address + "')"
                        try:
                            cursor.execute(cmd)
                        except psycopg2.Error as exc:
                            # Handle database-command errors.
                            raise Exception('dbCmd', exc.diag.message_primary + ": " + cmd, RV_ERROR_DBCMD)
                    elif etype == 'raConfirmation':
                        # confirmation was not found - delete from the user info table
                        cmd = 'SELECT * FROM ' + drms_params.EXPORT_USER_INFO_DELETE_FN + "('" + address + "')"
                        try:
                            cursor.execute(cmd)
                        except psycopg2.Error as exc:
                            # Handle database-command errors.
                            raise Exception('dbCmd', exc.diag.message_primary + ": " + cmd, RV_ERROR_DBCMD)
        else:
            if address:
                SendMailFailure(address, 'Please visit the export page and register your address again.')
            import traceback
            print('Unhandled exception: ' + traceback.format_exc(8) + '.' , file=sys.stderr)
            raise # Re-raise

    # It appears that sys.exit() does NOT flush streams.
    sys.stderr.flush()
    sys.exit(rv)
