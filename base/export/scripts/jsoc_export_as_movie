#!/bin/bash
export RGBDEF=/home/jsoc/cvs/Development/JSOC/proj/workflow/scripts/rgb.txt 
export JSOC_DBHOST=hmidb


#use as jsoc_export_as_movie  ds  reqid expversion  export_ method  protocol  output_path ffmt cparms    
#                        1    2       3             4            5           6        7      8    



#make sure all arguments are there

outpath=$6 
cd $outpath
#set env variables
tkey=T_REC

type=jpg    # default could also do jpg

#make sure all arguments are there
  if  (( $# != 8 ))
  then                                                
  echo "$0 requires 8 arguments"
    exit 2
  fi

    in=$1
    hglog=`echo $in | awk -F'[@]' /hg_patch.log/'{print $2}'`
    hg=`echo $in | grep hg` 
      
 if [ $hglog ]
  then
   nRec=`awk 'END{print NR}' $hglog`
   rm -rf *.$type ;rm -rf images;  rm -rf tmpImages/*.* ; rm -rf  *.mp4  
   rm -rf data*
 else    
   nRec=`show_info -cq ds=$in`
   rm -rf index.txt ; rm -rf tmpImages/*.* ; rm -rf  *.mp4  ;rm -f images;
    rm -rf *.$type;  rm -rf data* 
  
 fi
 
  if (( $nRec < 1 ))
 then 
     echo "No records exist"
      exit 2
  fi   

#if 
# [[ $type = [Jj][Pp][Gg] ]]
#then
#  outtype=`echo " '| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text #\"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95' " `
#else
#  outtype=$outpath    
#fi 



# chk to see if hg_patch -then need to append to existing index files else create new one after clobbering the old ones image files if they exist

# Write into the new index.txt

reqid=$2
echo "# JSOC " > index.txt
echo "reqid=$2" >>index.txt
echo "expversion=$3" >>index.txt  
echo "method=$4" >>index.txt  
echo "protocol=$5" >>index.txt  
echo "dir=$6" >>index.txt  
echo "filefmt=$7" >>index.txt  
echo "cparams=$8" >>index.txt  
echo "# DATA ">>index.txt

#check to see if its an AIA or HMI data set.

  instr=`echo $in | awk -F'[.]' 'NR==1{print substr($1, 1, 3)}' $hglog `
  seriesName=`echo $in | awk  -F'[[]' 'NR==1{print $1}' $hglog `
    
if [[ $instr == [Hh][Mm][Ii] ]] 
then    
 {
    #content=`show_info -q ds=$in n=1 key=CONTENT`
  
      content=`echo $in | awk  -F'[.]' 'NR==1{print substr($2, 1, 2)}' $hglog`
         tkey=T_REC
           junk=`show_info key=T_REC $in`
           if [ $? ]
              then 
               tkey=T_OBS
           fi
              

     if [ $hg ]
      then 
        declare -i scale=1     # default -could read in as a parameter
        p=u
      else
      declare -i scale=8  # default -could read in as a parameter
        p=c  
      fi     
      
       # hg=`echo $in | awk -F '[_]' '/hgpatch/{print $3}'`
      # or use:  if [ !  "echo $in | awk -F '[_]' '/hgpatch/{print $3}' " ] 


       # default could also do jpg
#declare -i size=4096/$scale      
 min_fl_sz=10000      #min file size

 seriesName=`echo $in | awk  -F'[[]' 'NR==1{print $1}' $hglog `
case "$content" in 
       
  M_) 
         render_image  in=$in  min=-1500 max=1500  pallette=/home/priya/Colormaps/grey.sao scaling=mag tkey=$tkey outname=$seriesName scale=$scale type=$type   out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95'  -{$p}  -c 
        
             ;;
  Ic)
           if [[ $seriesName = "Ic_noLimbDark" ]]
           then 
                  render_image in=$in   min=0.3	 max=1.4 scaling=minmaxgiven    pallette=/home/priya/Colormaps/heat.sao tkey=$tkey outname=$seriesName  scale=$scale  type=$type  out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95'   -{$p}  
          else
                  render_image in=$in  min=25000 max=75000    pallette=/home/priya/Colormaps/heat.sao outname=$seriesName  scale=$scale  type=$type  out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95'  -{$p}
          fi
             ;;
  Ld)
          render_image in=$in   pallette=/home/priya/Colormaps/bb.sao outname=$seriesName scale=$scale  type=$type tkey=$tkey  out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95'  -{$p}  -c
            ;;
  Lw)
         render_image in=$in   pallette=/home/priya/Colormaps/bb.sao outname=$seriesName scale=$scale type=$type tkey=$tkey out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95'  -{$p} -c
             ;;     
  V_)
         render_image in=$in  pallette=/home/priya/Colormaps/bb.sao outname=$seriesName scale=$scale type=$type tkey=$tkey out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/HMI  M:{ID}\" | pnmtojpeg -quality=95'   -{$p} -c
             ;;
        
   *) 
       echo -e Out of case command
             ;;
esac

 }

elif [[ $instr == [Aa][Ii][Aa] ]] 
 then
     { 
      if [ $hg ]
        then 
          declare -i scale=1     # default -could read in as a parameter
        p=u
         else
           declare -i scale=16  # default -could read in as a parameter
        p=c  
      fi     
      

     
        type=$type                # default could also do jpg
     
    seriesName=`echo $in | awk  -F'[[]' 'NR==1{print $1}' $hglog `
     min=100
       wvl_arr=(94 131 171 193 211 304 335 1600 1700 4500)
             max_val=(100 2000 2000 10000 10000 10000 1000 1000 2500 10000)
              for i in  0 1 2 3 4 5 6 7 8 9; do wvl=${wvl_arr[$i]}; let max_$wvl=${max_val[$i]}; done
              

       for wvl in 171 211 94 335 4500 1600 131 1700 193 304
          do 
            if [ $hglog ]
                then
                  in_new=$seriesName[RequestID=$reqid][WAVELNTH=$wvl]
                else
                  in_new=$in[WAVELNTH=$wvl]
            fi
   
            if [ $wvl == 171 ]
               then 
                 scaling=SQRT
               else 
                 scaling=LOG
            fi 
    
 
           tkey=T_REC
           junk=`show_info key=T_REC $in_new`
           if [ $? ]
              then 
               tkey=T_OBS
           fi
           
                         
                render_image in=$in_new  out='| ppmlabel -color black -size {%0.75:5} -x 15 -y {%98} -text \"SDO/AIA  M:{ID}\" | pnmtojpeg -quality=95'  pallette=/home/priya/Colormaps/AIA/aia_$wvl.lut tkey=$tkey  outname=aia_$wvl  min=$min max=$[max_$wvl]  scale=$scale outid=time  type=$type scaling=$scaling -w  -{$p}

          done 


}

else
  echo "P=png/Mpeg cannot be made for this dataset"
fi


#
#if [ "$hg" ]
#   then  
#size=`ls *.*.$type | awk -F'[_]'  'NR==1{print $2}' | awk -F'[.]'  '{print $1}' ` 
#   else 
#declare -i size=4096/$scale 
#fi

ls *.$type>images 
mkdir tmpImages

 N=`wc -l <images`
 i=1
  while (( $i  <=  $N ))
  do 
  img=`head --lines $i <images | tail -1`
  I=`printf "%04d" $i`
          if [[ -e $img ]]
          then 
              ln  $img  tmpImages/$I.$type
              let i+=1
            else
             echo "no frame for $img" 
               let i+=1
       fi 
 done

#make movie
cd tmpImages
ffmpeg -qscale 5 -r 20 -b 9600 -i  %04d.$type   ../$seriesName.mp4


cd ../

#write into index.txt
echo "Movie name=$seriesName.mp4" >>index.txt 
echo "# DATA ">>index.txt
 
if [ $hglog ]
then
 show_info -iq ds=$in n=1> data1
else
  show_info -iq ds=$in> data1
fi

echo "movie of the following data">>mv1
echo $seriesName.mp4 >>mv2
paste  mv1  mv2 >>index.txt 
paste  data1  images >> index.txt

#rm mv1;rm mv2
#rm -rf tmpImages/*.*
#rmdir tmpImages
#rm images

# rm -f $outpath/data1 ; rm -f $outpath/images 
# rm -f $outpath/*.png
 
 
 
 
